`timescale	1ps / 1ps
////////////////////////////////////////////////////////////////////////////////
//
// Filename:	./main.v
// {{{
// Project:	KIMOS, a Mercury KX2 demonstration project
//
// Computer Generated: This file is computer generated by AUTOFPGA. DO NOT EDIT.
// DO NOT EDIT THIS FILE!
//
// CmdLine:	autofpga -I / -d -o . allclocks.txt clkcheck.txt global.txt crossbus.txt icape.txt version.txt pic.txt pwrcount.txt rtccount.txt spio.txt exconsole.txt wbuuart.txt wbuarbiter.txt bkram.txt flash.txt flashcfg.txt ddr3.txt mem_sdram_only.txt mem_flash_sdram.txt zipmaster.txt mdio.txt meganet.txt protocols.txt eth0bus.txt sdio.txt flashscope.txt sdioscope.txt mem_flash_bkram.txt mem_bkram_only.txt xdc.txt i2ccpu.txt
//
// Creator:	Dan Gisselquist, Ph.D.
//		Gisselquist Technology, LLC
//
////////////////////////////////////////////////////////////////////////////////
// }}}
// Copyright (C) 2024, Gisselquist Technology, LLC
// {{{
// This file is part of the KIMOS project.
//
// The KIMOS project is free software and gateware: you can redistribute it
// and/or modify it under the terms of the GNU General Public License as
// published by the Free Software Foundation, either version 3 of the License,
// or (at your option) any later version.
//
// This program is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTIBILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// for more details.
//
// You should have received a copy of the GNU General Public License along
// with this program.  (It's in the $(ROOT)/doc directory.  Run make with no
// target there if the PDF file isn't present.)  If not, see
// <http://www.gnu.org/licenses/> for a copy.
// }}}
// License:	GPL, v3, as defined and found on www.gnu.org,
// {{{
//		http://www.gnu.org/licenses/gpl.html
//
////////////////////////////////////////////////////////////////////////////////
//
// }}}
`default_nettype	none
////////////////////////////////////////////////////////////////////////////////
//
// Macro defines
// {{{
//
//
// Here is a list of defines which may be used, post auto-design
// (not post-build), to turn particular peripherals (and bus masters)
// on and off.  In particular, to turn off support for a particular
// design component, just comment out its respective `define below.
//
// These lines are taken from the respective @ACCESS tags for each of our
// components.  If a component doesn't have an @ACCESS tag, it will not
// be listed here.
//
// First, the independent access fields for any bus masters
`define	EXBUS_MASTER
`define	ALLCLOCKS_PRESENT
// And then for the independent peripherals
`define	I2CCPU_ACCESS
`define	I2CDMA_ACCESS
`define	SDIO_ACCESS
`define	SPIO_ACCESS
`define	PWRCOUNT_ACCESS
`define	CFG_ACCESS
`define	VERSION_ACCESS
`define	ETH0_ACCESS
`define	RNTP_ACCESS
`define	NETCTRL_ACCESS
`define	FLASH_ACCESS
`define	BUSCONSOLE_ACCESS
`define	BKRAM_ACCESS
`define	DDR3_PHY_ACCESS
`define	SDRAM_ACCESS
`define	BUSPIC_ACCESS
`define	INCLUDE_ZIPCPU
//
//
// The list of those things that have @DEPENDS tags
//
//
//
// Dependencies
// Any core with both an @ACCESS and a @DEPENDS tag will show up here.
// The @DEPENDS tag will turn into a series of ifdef's, with the @ACCESS
// being defined only if all of the ifdef's are true//
// Deplist for @$(PREFIX)=flashdbg
`ifdef	FLASH_ACCESS
`define	FLASHSCOPE_SCOPC
`endif	// FLASH_ACCESS
// Deplist for @$(PREFIX)=adcclk
`ifdef	ALLCLOCKS_PRESENT
`define	ADCCLK
`endif	// ALLCLOCKS_PRESENT
// Deplist for @$(PREFIX)=txclk
`ifdef	ALLCLOCKS_PRESENT
`define	TXCLK
`endif	// ALLCLOCKS_PRESENT
// Deplist for @$(PREFIX)=sdioscope
`ifdef	SDIO_ACCESS
`define	SDIOSCOPE_SCOPC
`endif	// SDIO_ACCESS
// Deplist for @$(PREFIX)=flashcfg
`ifdef	FLASH_ACCESS
`define	FLASHCFG_ACCESS
`endif	// FLASH_ACCESS
// Deplist for @$(PREFIX)=eth0bus
`ifdef	ETH0_ACCESS
`define	ETH0BUS_ACCESS
`endif	// ETH0_ACCESS
// Deplist for @$(PREFIX)=rxeth0ck
`ifdef	ETH0_ACCESS
`define	RXETH0CK
`endif	// ETH0_ACCESS
//
// End of dependency list
//
//
// }}}
////////////////////////////////////////////////////////////////////////////////
//
// Any include files
// {{{
// These are drawn from anything with a MAIN.INCLUDE definition.
`include "builddate.v"
// }}}
//
// Finally, we define our main module itself.  We start with the list of
// I/O ports, or wires, passed into (or out of) the main function.
//
// These fields are copied verbatim from the respective I/O port lists,
// from the fields given by @MAIN.PORTLIST
//
module	main(i_clk, i_reset,
	// {{{
			i_i2c_sda, i_i2c_scl,
			o_i2c_sda, o_i2c_scl,
		// SDIO SD Card
		i_sdio_detect,
		//
		o_sdio_cfg_ddr,
		o_sdio_cfg_ds,
		o_sdio_cfg_dscmd,
		o_sdio_cfg_sample_shift,
		o_sdio_pp_cmd,
		o_sdio_pp_data,
		//
		o_sdio_sdclk,
		o_sdio_cmd_en,
		o_sdio_cmd_data,
		o_sdio_data_en,
		o_sdio_rx_en,
		o_sdio_tx_data,
		//
		i_sdio_cmd_strb,
		i_sdio_cmd_data,
		i_sdio_cmd_collision,
		i_sdio_card_busy,
		i_sdio_rx_strb,
		i_sdio_rx_data,
		//
		i_sdio_ac_valid,
		i_sdio_ac_data,
		i_sdio_ad_valid,
		i_sdio_ad_data,
		o_sdio_hwreset_n,
		i_sdio_debug,
		// SPIO interface
		i_btn, o_led,
		// UART/host to wishbone interface
		i_wbu_uart_rx, o_wbu_uart_tx,
                // Ethernet control (packets) lines
                // o_eth0_reset_n,
                // eth_int_b    // Interrupt, leave floating
                // eth_pme_b    // Power management event, leave floating
                i_eth0_rx_clk, i_eth0_rx_dv, i_eth0_rx_err, i_eth0_rxd,
                o_eth0_tx_clk, o_eth0_tx_ctl, o_eth0_txd,
		// The ethernet MDIO wires
		o_mdclk, o_mdio, o_mdwe, i_mdio,
		// The Universal QSPI Flash
		o_qspi_cs_n, o_qspi_sck, o_qspi_dat, i_qspi_dat, o_qspi_mod,
		// DDR3 Controller Interface
		i_ddr3_iserdes_data, i_ddr3_iserdes_dqs,
		i_ddr3_iserdes_bitslip_reference,
		i_ddr3_idelayctrl_rdy,
		o_ddr3_cmd,
		o_ddr3_dqs_tri_control, o_ddr3_dq_tri_control,
		o_ddr3_toggle_dqs, o_ddr3_data, o_ddr3_dm,
		o_ddr3_odelay_data_cntvaluein, o_ddr3_odelay_dqs_cntvaluein,
		o_ddr3_idelay_data_cntvaluein, o_ddr3_idelay_dqs_cntvaluein,
		o_ddr3_odelay_data_ld, o_ddr3_odelay_dqs_ld,
		o_ddr3_idelay_data_ld, o_ddr3_idelay_dqs_ld,
		o_ddr3_bitslip,
		o_ddr3_leveling_calib,
		o_ddr3_reset,
		// Extra clocks
		i_clk_200mhz, i_clk_125mhz,
		// Veri1ator only interface
		cpu_sim_cyc,
		cpu_sim_stb,
		cpu_sim_we,
		cpu_sim_addr,
		cpu_sim_data,
		cpu_sim_stall,
		cpu_sim_ack,
		cpu_sim_idata,
`ifdef	VERILATOR
		cpu_prof_stb,
		cpu_prof_addr,
		cpu_prof_ticks,
`endif
		i_cpu_reset
	// }}}
	);
////////////////////////////////////////////////////////////////////////////////
//
// Any parameter definitions
// {{{
// These are drawn from anything with a MAIN.PARAM definition.
// As they aren't connected to the toplevel at all, it would
// be best to use localparam over parameter, but here we don't
// check
	////////////////////////////////////////////////////////////////////////
	//
	// NETBUS parameters
	// {{{
	localparam	ETH0BUSWATCHDOG_RAW = 5 + 9;
	localparam	ETH0BUSWATCHDOG = (ETH0BUSWATCHDOG_RAW > 19)
				? ETH0BUSWATCHDOG_RAW : 19;
	// }}}
`ifndef	VERILATOR
	localparam	ICAPE_LGDIV=3;
`endif
	////////////////////////////////////////////////////////////////////////
	//
	// EXBUS parameters
	// {{{
	// Baudrate :   1000000
	// Clock    : 100000000
	localparam [23:0] BUSUART = 24'h64;	//   1000000 baud
	localparam	DBGBUSBITS = $clog2(BUSUART);
	// }}}
	parameter	[15:0]	UDP_DBGPORT  = 5929;

	localparam	[47:0]	DEF_ETH0_HWMAC  = 48'h8233_4802e1d0;
	localparam	[31:0]	DEF_ETH0_IPADDR = 32'hc0a80f1a;
	localparam real SDRAMCONTROLLER_CLK_PERIOD = 10, //ns, period of clock input to this DDR3 controller module
		DDR3_CLK_PERIOD = 2.5; //ns, period of clock input to DDR3 RAM device
	localparam SDRAMROW_BITS = 15,  // width of row address
		SDRAMCOL_BITS = 10,  // width of column address
		SDRAMBA_BITS  =  3,  // width of bank address
		SDRAMDQ_BITS  =  8,  // Size of one octet
		SDRAMLANES = 8, //8 lanes of DQ
		SDRAMAUX_WIDTH = 8, //must be 8 bits or more (also used in internal test and calibration)
		SDRAMSERDES_RATIO = $rtoi(SDRAMCONTROLLER_CLK_PERIOD/DDR3_CLK_PERIOD),
		//4 is the width of a single ddr3 command {cs_n, ras_n, cas_n, we_n} plus 3 (ck_en, odt, reset_n) plus bank bits plus row bits
		SDRAMCMD_LEN = 4 + 3 + SDRAMBA_BITS + SDRAMROW_BITS;


	////////////////////////////////////////////////////////////////////////
	//
	// Variables/definitions/parameters used by the ZipCPU bus master
	// {{{
	//
	// A 32-bit address indicating where the ZipCPU should start running
	// from
`ifdef	BKROM_ACCESS
	localparam	RESET_ADDRESS = @$(/bkrom.BASE);
`else
`ifdef	FLASH_ACCESS
	localparam	RESET_ADDRESS = 1153433600;
`else
	localparam	RESET_ADDRESS = 1241513984;
`endif	// FLASH_ACCESS
`endif	// BKROM_ACCESS
	//
	// The number of valid bits on the bus
	localparam	ZIP_ADDRESS_WIDTH = 25; // Zip-CPU address width
	//
	// Number of ZipCPU interrupts
	localparam	ZIP_INTS = 16;
	//
	// ZIP_START_HALTED
	//
	// A boolean, indicating whether or not the ZipCPU be halted on startup?
`ifdef	BKROM_ACCESS
	localparam	ZIP_START_HALTED=1'b0;
`else
	localparam	ZIP_START_HALTED=1'b1;
`endif
	// }}}
// }}}
////////////////////////////////////////////////////////////////////////////////
//
// Port declarations
// {{{
// The next step is to declare all of the various ports that were just
// listed above.  
//
// The following declarations are taken from the values of the various
// @MAIN.IODECL keys.
//
	input	wire		i_clk;
	// verilator lint_off UNUSED
	input	wire		i_reset;
	// verilator lint_on UNUSED
	// I2C Port declarations
	// {{{
	input	wire	i_i2c_sda, i_i2c_scl;
	output	wire	o_i2c_sda, o_i2c_scl;
	// }}}
	// SDIO SD Card declarations
	// {{{
	input	wire		i_sdio_detect;
		//
	output	wire		o_sdio_cfg_ddr;
	output	wire		o_sdio_cfg_ds;
	output	wire		o_sdio_cfg_dscmd;
	output	wire	[4:0]	o_sdio_cfg_sample_shift;
	output	wire		o_sdio_pp_cmd;
	output	wire		o_sdio_pp_data;
		//
	output	wire	[7:0]	o_sdio_sdclk;
	output	wire		o_sdio_cmd_en;
	output	wire	[1:0]	o_sdio_cmd_data;
	output	wire		o_sdio_data_en;
	output	wire		o_sdio_rx_en;
	output	wire	[31:0]	o_sdio_tx_data;
		//
	input	wire	[1:0]	i_sdio_cmd_strb;
	input	wire	[1:0]	i_sdio_cmd_data;
	input	wire		i_sdio_cmd_collision;
	input	wire		i_sdio_card_busy;
	input	wire	[1:0]	i_sdio_rx_strb;
	input	wire	[15:0]	i_sdio_rx_data;
		//
	input	wire		i_sdio_ac_valid;
	input	wire	[1:0]	i_sdio_ac_data;
	input	wire		i_sdio_ad_valid;
	input	wire	[31:0]	i_sdio_ad_data;
	output	wire		o_sdio_hwreset_n;
	// Verilator lint_off UNUSED
	input	wire	[31:0]	i_sdio_debug;
	// Verilator lint_on  UNUSED
	// }}}
	// SPIO interface
	input	wire	[2-1:0]	i_btn;
	output	wire	[8-1:0]	o_led;
	input	wire		i_wbu_uart_rx;
	output	wire		o_wbu_uart_tx;
        // Ethernet (RGMII) control
	// {{{
        input   wire            i_eth0_rx_clk, i_eth0_rx_dv, i_eth0_rx_err;
        input   wire    [7:0]   i_eth0_rxd;
        output  wire    [1:0]   o_eth0_tx_clk;
        output  wire            o_eth0_tx_ctl;
        output  wire    [7:0]   o_eth0_txd;
	// }}}
	// Ethernet control (MDIO)
	output	wire		o_mdclk, o_mdio, o_mdwe;
	input	wire		i_mdio;
	// The Universal QSPI flash
	output	wire		o_qspi_cs_n, o_qspi_sck;
	output	wire	[3:0]	o_qspi_dat;
	input	wire	[3:0]	i_qspi_dat;
	output	wire	[1:0]	o_qspi_mod;
	// DDR3 Controller I/O declarations
	// {{{
	input	wire	[SDRAMDQ_BITS*SDRAMLANES*8-1:0] i_ddr3_iserdes_data;
	input wire    [SDRAMLANES*8-1:0] i_ddr3_iserdes_dqs;
	input wire    [SDRAMLANES*8-1:0] i_ddr3_iserdes_bitslip_reference;
	input wire    i_ddr3_idelayctrl_rdy;
	output wire    [SDRAMCMD_LEN*SDRAMSERDES_RATIO-1:0] o_ddr3_cmd;
	output wire    o_ddr3_dqs_tri_control, o_ddr3_dq_tri_control;
	output wire    o_ddr3_toggle_dqs;
	output wire    [SDRAMDQ_BITS*SDRAMLANES*8-1:0] o_ddr3_data;
	output wire    [(SDRAMDQ_BITS*SDRAMLANES*8)/8-1:0] o_ddr3_dm;
	output wire    [4:0] o_ddr3_odelay_data_cntvaluein, o_ddr3_odelay_dqs_cntvaluein;
	output wire    [4:0] o_ddr3_idelay_data_cntvaluein, o_ddr3_idelay_dqs_cntvaluein;
	output wire    [SDRAMLANES-1:0] o_ddr3_odelay_data_ld, o_ddr3_odelay_dqs_ld;
	output wire    [SDRAMLANES-1:0] o_ddr3_idelay_data_ld, o_ddr3_idelay_dqs_ld;
	output wire    [SDRAMLANES-1:0] o_ddr3_bitslip;
	output wire    o_ddr3_leveling_calib;
	output wire    o_ddr3_reset;
	// }}}
	// Extra clocks
	// Verilator lint_off UNUSED
	input	wire		i_clk_200mhz, i_clk_125mhz; // i_clk_150mhz
	// Verilator lint_on  UNUSED
	input	wire		cpu_sim_cyc, cpu_sim_stb;
	input	wire		cpu_sim_we;
	input	wire	[6:0]	cpu_sim_addr;
	input	wire	[31:0]	cpu_sim_data;
	//
	output	wire		cpu_sim_stall, cpu_sim_ack;
	output	wire	[31:0]	cpu_sim_idata;
	//
`ifdef	VERILATOR
	output	wire		cpu_prof_stb;
	output	wire	[25+$clog2(512/8)-1:0]	cpu_prof_addr;
	output	wire [31:0]	cpu_prof_ticks;
`endif
	input	wire		i_cpu_reset;
// }}}
	// Make Verilator happy
	// {{{
	// Defining bus wires for lots of components often ends up with unused
	// wires lying around.  We'll turn off Ver1lator's lint warning
	// here that checks for unused wires.
	// }}}
	// verilator lint_off UNUSED
	////////////////////////////////////////////////////////////////////////
	//
	// Declaring interrupt lines
	// {{{
	// These declarations come from the various components values
	// given under the @INT.<interrupt name>.WIRE key.
	//
	wire	sdio_int;	// sdio.INT.SDCARD.WIRE
	wire	spio_int;	// spio.INT.SPIO.WIRE
	wire	sdioscope_int;	// sdioscope.INT.SDIOSCOPE.WIRE
	wire	flashdbg_int;	// flashdbg.INT.FLASHDBG.WIRE
	wire	uartrxf_int;	// uart.INT.UARTRXF.WIRE
	wire	uarttx_int;	// uart.INT.UARTTX.WIRE
	wire	uarttxf_int;	// uart.INT.UARTTXF.WIRE
	wire	uartrx_int;	// uart.INT.UARTRX.WIRE
	wire	w_bus_int;	// buspic.INT.BUS.WIRE
	wire	zip_cpu_int;	// zip.INT.ZIP.WIRE
	// }}}
	////////////////////////////////////////////////////////////////////////
	//
	// Component declarations
	// {{{
	// These declarations come from the @MAIN.DEFNS keys found in the
	// various components comprising the design.
	//
	// I2C Controller
	// {{{
	// Verilator lint_off UNUSED
	localparam	I2C_ID_WIDTH=(2 == 0) ? 1 : 2;

	wire		i2c_valid, i2c_ready, i2c_last;
	wire	[7:0]	i2c_data;
	wire	[I2C_ID_WIDTH-1:0]	i2c_id;

	wire	[31:0]	i2c_debug;
	// Verilator lint_on  UNUSED
	// }}}
	wire	i2cdma_ready;
	// SDIO SD Card definitions
	// Verilator lint_off UNUSED
	wire	[31:0]	w_sdio_sub_debug;
	wire		w_sdio_1p8v, s_sdio_ready,
			m_sdio_valid, m_sdio_last;
	reg	[31:0]	sdio_debug;
	wire	[31:0]	m_sdio_data;
	// assign		sdio_debug = i_sdio_debug;
	// Verilator lint_on  UNUSED
	////////////////////////////////////////////////////////////////////////
	//
	// NETBUS signals
	// {{{
	// Verilator lint_off UNUSED
	wire	[29:0]	eth0bus_tmp_addr;
	wire	[9:0]	eth0bus_gpout;
	// Verilator lint_on  UNUSED

	wire		eth0bus_tvalid, eth0bus_tready;
	wire	[31:0]	eth0bus_tdata;
	wire		w_eth0bus_int; // 1'b0;
	// Verilator lint_off UNUSED
	wire	[31:0]	eth0bus_debug;
	// Verilator lint_on  UNUSED
	// }}}
	wire	[8-1:0]	w_led;
	wire			w_sw;	// Since this design has no switches
`ifndef	TIMESYNC
	reg	[31:0]	r_rtccount_data;
`endif
	reg	[31:0]	r_pwrcount_data;
	////////////////////////////////////////////////////////////////////////
	//
	// EXBUS: USB-UART interface declarations
	// {{{
	//
	wire	[7:0]	wbu_rx_data, wbu_tx_data;
	wire		wbu_rx_stb;
	wire		wbu_tx_stb, wbu_tx_busy;

	// Verilator lint_off UNUSED
	wire	[0:0]	ex_reset;
	wire	[1:0]	ex_gpio;
	// Verilator lint_on  UNUSED
	// }}}
        // Ethernet (RGMII) control
	// {{{
	// Verilator lint_off UNUSED
	// Verilator lint_off SYNCASYNCNET
	wire		w_eth0_reset_n;
	// Verilator lint_on  SYNCASYNCNET
	wire	[47:0]	eth0_hwmac, eth0_last_ping_hwmac;
	wire	[31:0]	eth0_ip_addr, eth0_last_ping_ipaddr;

	wire		eth0cpurx_valid, eth0cpurx_ready;
	wire	[31:0]	eth0cpurx_data;
	wire		eth0cpurx_last, eth0cpurx_abort;

	wire		eth0cputx_tvalid, eth0cputx_tready;
	wire	[31:0]	eth0cputx_tdata;

	wire		eth0_dbg_tvalid, eth0_dbg_tready, eth0_dbg_tlast;
	wire	[31:0]	eth0_dbg_tdata;

	wire		eth0_high_speed;

	wire		eth0_debug_clk;
	wire	[31:0]	eth0_debug;
`ifndef	ETH0_NO_ACCESS
	wire		ign_rxpkt_eth0_ready;
`endif
	// Verilator lint_on  UNUSED
	// }}}
	// Verilator lint_off UNUSED
	reg	r_txclk_ack;
	// Verilator lint_on  UNUSED
// BUILDTIME doesnt need to include builddate.v a second time
// `include "builddate.v"
	// Verilator lint_off UNUSED
	reg	r_rxeth0ck_ack;
	// Verilator lint_on  UNUSED
	// Verilator lint_off UNUSED
	reg	r_adcclk_ack;
	// Verilator lint_on  UNUSED
	// Definitions for the flash debug port
	// Verilator lint_off UNUSED
	wire		flash_dbg_trigger;
	wire	[31:0]	flash_debug;
	// Verilator lint_on  UNUSED
	// Verilator lint_off UNUSED
	reg		ck_pps;
	reg	[26:0]	ck_pps_counter;
	// Verilator lint_on  UNUSED
	////////////////////////////////////////////////////////////////////////
	//
	// WBUBUS: Console definitions
	// {{{
	wire		w_console_rx_stb, w_console_tx_stb, w_console_busy;
	wire	[6:0]	w_console_rx_data, w_console_tx_data;
	// Verilator lint_off UNUSED
	wire	[31:0]	uart_debug;
	// Verilator lint_on  UNUSED
	// }}}
	// Verilator lint_off UNUSED
	wire	[SDRAMAUX_WIDTH-1:0]	ddr3_aux_out;
	wire	[31:0]	ddr3_debug1, ddr3_debug2, ddr3_debug3;
	// Verilator lint_on  UNUSED
	// Verilator lint_off UNUSED
	wire	i_net_tx_clk;
	// Verilator lint_on  UNUSED
	////////////////////////////////////////////////////////////////////////
	//
	// ZipSystem/ZipCPU connection definitions
	// {{{
`ifndef	VERILATOR
	wire		cpu_prof_stb;
	wire	[25+$clog2(512/8)-1:0]	cpu_prof_addr;
	wire [31:0]	cpu_prof_ticks;
`endif
	// All we define here is a set of scope wires
	// Verilator lint_off UNUSED
	wire		raw_cpu_dbg_stall, raw_cpu_dbg_ack;
	wire	[31:0]	zip_debug;
	wire		zip_trigger;
	// Verilator lint_on  UNUSED
	wire	[ZIP_INTS-1:0] zip_int_vector;
	// }}}

// }}}
	////////////////////////////////////////////////////////////////////////
	//
	// Declaring interrupt vector wires
	// {{{
	// These declarations come from the various components having
	// PIC and PIC.MAX keys.
	//
	wire	[14:0]	alt_int_vector;
	wire	[14:0]	bus_int_vector;
	wire	[14:0]	sys_int_vector;
	// }}}
	////////////////////////////////////////////////////////////////////////
	//
	// Declare bus signals
	// {{{
	////////////////////////////////////////////////////////////////////////

	// Bus wbwide
	// {{{
	// Wishbone definitions for bus wbwide, component i2c
	// Verilator lint_off UNUSED
	wire		wbwide_i2cm_cyc, wbwide_i2cm_stb, wbwide_i2cm_we;
	wire	[24:0]	wbwide_i2cm_addr;
	wire	[511:0]	wbwide_i2cm_data;
	wire	[63:0]	wbwide_i2cm_sel;
	wire		wbwide_i2cm_stall, wbwide_i2cm_ack, wbwide_i2cm_err;
	wire	[511:0]	wbwide_i2cm_idata;
	// Verilator lint_on UNUSED
	// Wishbone definitions for bus wbwide, component i2cdma
	// Verilator lint_off UNUSED
	wire		wbwide_i2cdma_cyc, wbwide_i2cdma_stb, wbwide_i2cdma_we;
	wire	[24:0]	wbwide_i2cdma_addr;
	wire	[511:0]	wbwide_i2cdma_data;
	wire	[63:0]	wbwide_i2cdma_sel;
	wire		wbwide_i2cdma_stall, wbwide_i2cdma_ack, wbwide_i2cdma_err;
	wire	[511:0]	wbwide_i2cdma_idata;
	// Verilator lint_on UNUSED
	// Wishbone definitions for bus wbwide, component sdio
	// Verilator lint_off UNUSED
	wire		wbwide_sdio_cyc, wbwide_sdio_stb, wbwide_sdio_we;
	wire	[24:0]	wbwide_sdio_addr;
	wire	[511:0]	wbwide_sdio_data;
	wire	[63:0]	wbwide_sdio_sel;
	wire		wbwide_sdio_stall, wbwide_sdio_ack, wbwide_sdio_err;
	wire	[511:0]	wbwide_sdio_idata;
	// Verilator lint_on UNUSED
	// Wishbone definitions for bus wbwide, component wbu_arbiter
	// Verilator lint_off UNUSED
	wire		wbwide_wbu_arbiter_cyc, wbwide_wbu_arbiter_stb, wbwide_wbu_arbiter_we;
	wire	[24:0]	wbwide_wbu_arbiter_addr;
	wire	[511:0]	wbwide_wbu_arbiter_data;
	wire	[63:0]	wbwide_wbu_arbiter_sel;
	wire		wbwide_wbu_arbiter_stall, wbwide_wbu_arbiter_ack, wbwide_wbu_arbiter_err;
	wire	[511:0]	wbwide_wbu_arbiter_idata;
	// Verilator lint_on UNUSED
	// Wishbone definitions for bus wbwide, component zip
	// Verilator lint_off UNUSED
	wire		wbwide_zip_cyc, wbwide_zip_stb, wbwide_zip_we;
	wire	[24:0]	wbwide_zip_addr;
	wire	[511:0]	wbwide_zip_data;
	wire	[63:0]	wbwide_zip_sel;
	wire		wbwide_zip_stall, wbwide_zip_ack, wbwide_zip_err;
	wire	[511:0]	wbwide_zip_idata;
	// Verilator lint_on UNUSED
	// Wishbone definitions for bus wbwide, component ddr3
	// Verilator lint_off UNUSED
	wire		wbwide_ddr3_cyc, wbwide_ddr3_stb, wbwide_ddr3_we;
	wire	[24:0]	wbwide_ddr3_addr;
	wire	[511:0]	wbwide_ddr3_data;
	wire	[63:0]	wbwide_ddr3_sel;
	wire		wbwide_ddr3_stall, wbwide_ddr3_ack, wbwide_ddr3_err;
	wire	[511:0]	wbwide_ddr3_idata;
	// Verilator lint_on UNUSED
	// Wishbone definitions for bus wbwide, component crossflash
	// Verilator lint_off UNUSED
	wire		wbwide_crossflash_cyc, wbwide_crossflash_stb, wbwide_crossflash_we;
	wire	[24:0]	wbwide_crossflash_addr;
	wire	[511:0]	wbwide_crossflash_data;
	wire	[63:0]	wbwide_crossflash_sel;
	wire		wbwide_crossflash_stall, wbwide_crossflash_ack, wbwide_crossflash_err;
	wire	[511:0]	wbwide_crossflash_idata;
	// Verilator lint_on UNUSED
	// Wishbone definitions for bus wbwide, component crossbus
	// Verilator lint_off UNUSED
	wire		wbwide_crossbus_cyc, wbwide_crossbus_stb, wbwide_crossbus_we;
	wire	[24:0]	wbwide_crossbus_addr;
	wire	[511:0]	wbwide_crossbus_data;
	wire	[63:0]	wbwide_crossbus_sel;
	wire		wbwide_crossbus_stall, wbwide_crossbus_ack, wbwide_crossbus_err;
	wire	[511:0]	wbwide_crossbus_idata;
	// Verilator lint_on UNUSED
	// Wishbone definitions for bus wbwide, component bkram
	// Verilator lint_off UNUSED
	wire		wbwide_bkram_cyc, wbwide_bkram_stb, wbwide_bkram_we;
	wire	[24:0]	wbwide_bkram_addr;
	wire	[511:0]	wbwide_bkram_data;
	wire	[63:0]	wbwide_bkram_sel;
	wire		wbwide_bkram_stall, wbwide_bkram_ack, wbwide_bkram_err;
	wire	[511:0]	wbwide_bkram_idata;
	// Verilator lint_on UNUSED
	// }}}
	// Bus wb32
	// {{{
	// Wishbone definitions for bus wb32, component crossbus
	// Verilator lint_off UNUSED
	wire		wb32_crossbus_cyc, wb32_crossbus_stb, wb32_crossbus_we;
	wire	[10:0]	wb32_crossbus_addr;
	wire	[31:0]	wb32_crossbus_data;
	wire	[3:0]	wb32_crossbus_sel;
	wire		wb32_crossbus_stall, wb32_crossbus_ack, wb32_crossbus_err;
	wire	[31:0]	wb32_crossbus_idata;
	// Verilator lint_on UNUSED
	// Wishbone definitions for bus wb32(SIO), component adcclk
	// Verilator lint_off UNUSED
	wire		wb32_adcclk_cyc, wb32_adcclk_stb, wb32_adcclk_we;
	wire	[10:0]	wb32_adcclk_addr;
	wire	[31:0]	wb32_adcclk_data;
	wire	[3:0]	wb32_adcclk_sel;
	wire		wb32_adcclk_stall, wb32_adcclk_ack, wb32_adcclk_err;
	wire	[31:0]	wb32_adcclk_idata;
	// Verilator lint_on UNUSED
	// Wishbone definitions for bus wb32(SIO), component buildtime
	// Verilator lint_off UNUSED
	wire		wb32_buildtime_cyc, wb32_buildtime_stb, wb32_buildtime_we;
	wire	[10:0]	wb32_buildtime_addr;
	wire	[31:0]	wb32_buildtime_data;
	wire	[3:0]	wb32_buildtime_sel;
	wire		wb32_buildtime_stall, wb32_buildtime_ack, wb32_buildtime_err;
	wire	[31:0]	wb32_buildtime_idata;
	// Verilator lint_on UNUSED
	// Wishbone definitions for bus wb32(SIO), component buspic
	// Verilator lint_off UNUSED
	wire		wb32_buspic_cyc, wb32_buspic_stb, wb32_buspic_we;
	wire	[10:0]	wb32_buspic_addr;
	wire	[31:0]	wb32_buspic_data;
	wire	[3:0]	wb32_buspic_sel;
	wire		wb32_buspic_stall, wb32_buspic_ack, wb32_buspic_err;
	wire	[31:0]	wb32_buspic_idata;
	// Verilator lint_on UNUSED
	// Wishbone definitions for bus wb32(SIO), component pwrcount
	// Verilator lint_off UNUSED
	wire		wb32_pwrcount_cyc, wb32_pwrcount_stb, wb32_pwrcount_we;
	wire	[10:0]	wb32_pwrcount_addr;
	wire	[31:0]	wb32_pwrcount_data;
	wire	[3:0]	wb32_pwrcount_sel;
	wire		wb32_pwrcount_stall, wb32_pwrcount_ack, wb32_pwrcount_err;
	wire	[31:0]	wb32_pwrcount_idata;
	// Verilator lint_on UNUSED
	// Wishbone definitions for bus wb32(SIO), component rtccount
	// Verilator lint_off UNUSED
	wire		wb32_rtccount_cyc, wb32_rtccount_stb, wb32_rtccount_we;
	wire	[10:0]	wb32_rtccount_addr;
	wire	[31:0]	wb32_rtccount_data;
	wire	[3:0]	wb32_rtccount_sel;
	wire		wb32_rtccount_stall, wb32_rtccount_ack, wb32_rtccount_err;
	wire	[31:0]	wb32_rtccount_idata;
	// Verilator lint_on UNUSED
	// Wishbone definitions for bus wb32(SIO), component rxeth0ck
	// Verilator lint_off UNUSED
	wire		wb32_rxeth0ck_cyc, wb32_rxeth0ck_stb, wb32_rxeth0ck_we;
	wire	[10:0]	wb32_rxeth0ck_addr;
	wire	[31:0]	wb32_rxeth0ck_data;
	wire	[3:0]	wb32_rxeth0ck_sel;
	wire		wb32_rxeth0ck_stall, wb32_rxeth0ck_ack, wb32_rxeth0ck_err;
	wire	[31:0]	wb32_rxeth0ck_idata;
	// Verilator lint_on UNUSED
	// Wishbone definitions for bus wb32(SIO), component spio
	// Verilator lint_off UNUSED
	wire		wb32_spio_cyc, wb32_spio_stb, wb32_spio_we;
	wire	[10:0]	wb32_spio_addr;
	wire	[31:0]	wb32_spio_data;
	wire	[3:0]	wb32_spio_sel;
	wire		wb32_spio_stall, wb32_spio_ack, wb32_spio_err;
	wire	[31:0]	wb32_spio_idata;
	// Verilator lint_on UNUSED
	// Wishbone definitions for bus wb32(SIO), component txclk
	// Verilator lint_off UNUSED
	wire		wb32_txclk_cyc, wb32_txclk_stb, wb32_txclk_we;
	wire	[10:0]	wb32_txclk_addr;
	wire	[31:0]	wb32_txclk_data;
	wire	[3:0]	wb32_txclk_sel;
	wire		wb32_txclk_stall, wb32_txclk_ack, wb32_txclk_err;
	wire	[31:0]	wb32_txclk_idata;
	// Verilator lint_on UNUSED
	// Wishbone definitions for bus wb32(SIO), component version
	// Verilator lint_off UNUSED
	wire		wb32_version_cyc, wb32_version_stb, wb32_version_we;
	wire	[10:0]	wb32_version_addr;
	wire	[31:0]	wb32_version_data;
	wire	[3:0]	wb32_version_sel;
	wire		wb32_version_stall, wb32_version_ack, wb32_version_err;
	wire	[31:0]	wb32_version_idata;
	// Verilator lint_on UNUSED
	// Wishbone definitions for bus wb32, component flashcfg
	// Verilator lint_off UNUSED
	wire		wb32_flashcfg_cyc, wb32_flashcfg_stb, wb32_flashcfg_we;
	wire	[10:0]	wb32_flashcfg_addr;
	wire	[31:0]	wb32_flashcfg_data;
	wire	[3:0]	wb32_flashcfg_sel;
	wire		wb32_flashcfg_stall, wb32_flashcfg_ack, wb32_flashcfg_err;
	wire	[31:0]	wb32_flashcfg_idata;
	// Verilator lint_on UNUSED
	// Wishbone definitions for bus wb32, component flashdbg
	// Verilator lint_off UNUSED
	wire		wb32_flashdbg_cyc, wb32_flashdbg_stb, wb32_flashdbg_we;
	wire	[10:0]	wb32_flashdbg_addr;
	wire	[31:0]	wb32_flashdbg_data;
	wire	[3:0]	wb32_flashdbg_sel;
	wire		wb32_flashdbg_stall, wb32_flashdbg_ack, wb32_flashdbg_err;
	wire	[31:0]	wb32_flashdbg_idata;
	// Verilator lint_on UNUSED
	// Wishbone definitions for bus wb32, component sdioscope
	// Verilator lint_off UNUSED
	wire		wb32_sdioscope_cyc, wb32_sdioscope_stb, wb32_sdioscope_we;
	wire	[10:0]	wb32_sdioscope_addr;
	wire	[31:0]	wb32_sdioscope_data;
	wire	[3:0]	wb32_sdioscope_sel;
	wire		wb32_sdioscope_stall, wb32_sdioscope_ack, wb32_sdioscope_err;
	wire	[31:0]	wb32_sdioscope_idata;
	// Verilator lint_on UNUSED
	// Wishbone definitions for bus wb32, component i2c
	// Verilator lint_off UNUSED
	wire		wb32_i2cs_cyc, wb32_i2cs_stb, wb32_i2cs_we;
	wire	[10:0]	wb32_i2cs_addr;
	wire	[31:0]	wb32_i2cs_data;
	wire	[3:0]	wb32_i2cs_sel;
	wire		wb32_i2cs_stall, wb32_i2cs_ack, wb32_i2cs_err;
	wire	[31:0]	wb32_i2cs_idata;
	// Verilator lint_on UNUSED
	// Wishbone definitions for bus wb32, component i2cdma
	// Verilator lint_off UNUSED
	wire		wb32_i2cdma_cyc, wb32_i2cdma_stb, wb32_i2cdma_we;
	wire	[10:0]	wb32_i2cdma_addr;
	wire	[31:0]	wb32_i2cdma_data;
	wire	[3:0]	wb32_i2cdma_sel;
	wire		wb32_i2cdma_stall, wb32_i2cdma_ack, wb32_i2cdma_err;
	wire	[31:0]	wb32_i2cdma_idata;
	// Verilator lint_on UNUSED
	// Wishbone definitions for bus wb32, component uart
	// Verilator lint_off UNUSED
	wire		wb32_uart_cyc, wb32_uart_stb, wb32_uart_we;
	wire	[10:0]	wb32_uart_addr;
	wire	[31:0]	wb32_uart_data;
	wire	[3:0]	wb32_uart_sel;
	wire		wb32_uart_stall, wb32_uart_ack, wb32_uart_err;
	wire	[31:0]	wb32_uart_idata;
	// Verilator lint_on UNUSED
	// Wishbone definitions for bus wb32, component wb32_sio
	// Verilator lint_off UNUSED
	wire		wb32_sio_cyc, wb32_sio_stb, wb32_sio_we;
	wire	[10:0]	wb32_sio_addr;
	wire	[31:0]	wb32_sio_data;
	wire	[3:0]	wb32_sio_sel;
	wire		wb32_sio_stall, wb32_sio_ack, wb32_sio_err;
	wire	[31:0]	wb32_sio_idata;
	// Verilator lint_on UNUSED
	// Wishbone definitions for bus wb32, component cfg
	// Verilator lint_off UNUSED
	wire		wb32_cfg_cyc, wb32_cfg_stb, wb32_cfg_we;
	wire	[10:0]	wb32_cfg_addr;
	wire	[31:0]	wb32_cfg_data;
	wire	[3:0]	wb32_cfg_sel;
	wire		wb32_cfg_stall, wb32_cfg_ack, wb32_cfg_err;
	wire	[31:0]	wb32_cfg_idata;
	// Verilator lint_on UNUSED
	// Wishbone definitions for bus wb32, component eth0
	// Verilator lint_off UNUSED
	wire		wb32_eth0_cyc, wb32_eth0_stb, wb32_eth0_we;
	wire	[10:0]	wb32_eth0_addr;
	wire	[31:0]	wb32_eth0_data;
	wire	[3:0]	wb32_eth0_sel;
	wire		wb32_eth0_stall, wb32_eth0_ack, wb32_eth0_err;
	wire	[31:0]	wb32_eth0_idata;
	// Verilator lint_on UNUSED
	// Wishbone definitions for bus wb32, component ddr3_phy
	// Verilator lint_off UNUSED
	wire		wb32_ddr3_phy_cyc, wb32_ddr3_phy_stb, wb32_ddr3_phy_we;
	wire	[10:0]	wb32_ddr3_phy_addr;
	wire	[31:0]	wb32_ddr3_phy_data;
	wire	[3:0]	wb32_ddr3_phy_sel;
	wire		wb32_ddr3_phy_stall, wb32_ddr3_phy_ack, wb32_ddr3_phy_err;
	wire	[31:0]	wb32_ddr3_phy_idata;
	// Verilator lint_on UNUSED
	// Wishbone definitions for bus wb32, component mdio
	// Verilator lint_off UNUSED
	wire		wb32_mdio_cyc, wb32_mdio_stb, wb32_mdio_we;
	wire	[10:0]	wb32_mdio_addr;
	wire	[31:0]	wb32_mdio_data;
	wire	[3:0]	wb32_mdio_sel;
	wire		wb32_mdio_stall, wb32_mdio_ack, wb32_mdio_err;
	wire	[31:0]	wb32_mdio_idata;
	// Verilator lint_on UNUSED
	// }}}
	// Bus wbflash
	// {{{
	// Wishbone definitions for bus wbflash, component crossflash
	// Verilator lint_off UNUSED
	wire		wbflash_crossflash_cyc, wbflash_crossflash_stb, wbflash_crossflash_we;
	wire	[24:0]	wbflash_crossflash_addr;
	wire	[31:0]	wbflash_crossflash_data;
	wire	[3:0]	wbflash_crossflash_sel;
	wire		wbflash_crossflash_stall, wbflash_crossflash_ack, wbflash_crossflash_err;
	wire	[31:0]	wbflash_crossflash_idata;
	// Verilator lint_on UNUSED
	// Wishbone definitions for bus wbflash, component sdio
	// Verilator lint_off UNUSED
	wire		wbflash_sdio_cyc, wbflash_sdio_stb, wbflash_sdio_we;
	wire	[24:0]	wbflash_sdio_addr;
	wire	[31:0]	wbflash_sdio_data;
	wire	[3:0]	wbflash_sdio_sel;
	wire		wbflash_sdio_stall, wbflash_sdio_ack, wbflash_sdio_err;
	wire	[31:0]	wbflash_sdio_idata;
	// Verilator lint_on UNUSED
	// Wishbone definitions for bus wbflash, component flash
	// Verilator lint_off UNUSED
	wire		wbflash_flash_cyc, wbflash_flash_stb, wbflash_flash_we;
	wire	[24:0]	wbflash_flash_addr;
	wire	[31:0]	wbflash_flash_data;
	wire	[3:0]	wbflash_flash_sel;
	wire		wbflash_flash_stall, wbflash_flash_ack, wbflash_flash_err;
	wire	[31:0]	wbflash_flash_idata;
	// Verilator lint_on UNUSED
	// }}}
	// Bus wbu
	// {{{
	// Wishbone definitions for bus wbu, component eth0bus
	// Verilator lint_off UNUSED
	wire		eth0bus_cyc, eth0bus_stb, eth0bus_we;
	wire	[29:0]	eth0bus_addr;
	wire	[31:0]	eth0bus_data;
	wire	[3:0]	eth0bus_sel;
	wire		eth0bus_stall, eth0bus_ack, eth0bus_err;
	wire	[31:0]	eth0bus_idata;
	// Verilator lint_on UNUSED
	// Wishbone definitions for bus wbu, component wbu
	// Verilator lint_off UNUSED
	wire		wbu_cyc, wbu_stb, wbu_we;
	wire	[29:0]	wbu_addr;
	wire	[31:0]	wbu_data;
	wire	[3:0]	wbu_sel;
	wire		wbu_stall, wbu_ack, wbu_err;
	wire	[31:0]	wbu_idata;
	// Verilator lint_on UNUSED
	// Wishbone definitions for bus wbu, component wbu_arbiter
	// Verilator lint_off UNUSED
	wire		wbu_wbu_arbiter_cyc, wbu_wbu_arbiter_stb, wbu_wbu_arbiter_we;
	wire	[29:0]	wbu_wbu_arbiter_addr;
	wire	[31:0]	wbu_wbu_arbiter_data;
	wire	[3:0]	wbu_wbu_arbiter_sel;
	wire		wbu_wbu_arbiter_stall, wbu_wbu_arbiter_ack, wbu_wbu_arbiter_err;
	wire	[31:0]	wbu_wbu_arbiter_idata;
	// Verilator lint_on UNUSED
	// Wishbone definitions for bus wbu, component zip
	// Verilator lint_off UNUSED
	wire		wbu_zip_cyc, wbu_zip_stb, wbu_zip_we;
	wire	[29:0]	wbu_zip_addr;
	wire	[31:0]	wbu_zip_data;
	wire	[3:0]	wbu_zip_sel;
	wire		wbu_zip_stall, wbu_zip_ack, wbu_zip_err;
	wire	[31:0]	wbu_zip_idata;
	// Verilator lint_on UNUSED
	// }}}
	// }}}
	////////////////////////////////////////////////////////////////////////
	//
	// Peripheral address decoding, bus handling
	// {{{
	//
	// BUS-LOGIC for wbwide
	// {{{
	//
	// No class SINGLE peripherals on the "wbwide" bus
	//

	//
	// No class DOUBLE peripherals on the "wbwide" bus
	//

	assign	wbwide_ddr3_err= 1'b0;
	// info: @ERROR.WIRE for crossflash matches the buses error name, wbwide_crossflash_err
	// info: @ERROR.WIRE for crossbus matches the buses error name, wbwide_crossbus_err
	assign	wbwide_bkram_err= 1'b0;
	//
	// Connect the wbwide bus components together using the wbxbar()
	//
	//
	wbxbar #(
		.NM(5), .NS(4), .AW(25), .DW(512),
		.SLAVE_ADDR({
			// Address width    = 25
			// Address LSBs     = 6
			{ 25'h1280000 }, //      bkram: 0x4a000000
			{ 25'h1200000 }, //   crossbus: 0x48000000
			{ 25'h1000000 }, // crossflash: 0x40000000
			{ 25'h0000000 }  //       ddr3: 0x00000000
		}),
		.SLAVE_MASK({
			// Address width    = 25
			// Address LSBs     = 6
			{ 25'h1f80000 }, //      bkram
			{ 25'h1f80000 }, //   crossbus
			{ 25'h1e00000 }, // crossflash
			{ 25'h1000000 }  //       ddr3
		}),
		.OPT_DBLBUFFER(1'b1))
	wbwide_xbar(
		.i_clk(i_clk), .i_reset(i_reset),
		.i_mcyc({
			wbwide_zip_cyc,
			wbwide_wbu_arbiter_cyc,
			wbwide_sdio_cyc,
			wbwide_i2cdma_cyc,
			wbwide_i2cm_cyc
		}),
		.i_mstb({
			wbwide_zip_stb,
			wbwide_wbu_arbiter_stb,
			wbwide_sdio_stb,
			wbwide_i2cdma_stb,
			wbwide_i2cm_stb
		}),
		.i_mwe({
			wbwide_zip_we,
			wbwide_wbu_arbiter_we,
			wbwide_sdio_we,
			wbwide_i2cdma_we,
			wbwide_i2cm_we
		}),
		.i_maddr({
			wbwide_zip_addr,
			wbwide_wbu_arbiter_addr,
			wbwide_sdio_addr,
			wbwide_i2cdma_addr,
			wbwide_i2cm_addr
		}),
		.i_mdata({
			wbwide_zip_data,
			wbwide_wbu_arbiter_data,
			wbwide_sdio_data,
			wbwide_i2cdma_data,
			wbwide_i2cm_data
		}),
		.i_msel({
			wbwide_zip_sel,
			wbwide_wbu_arbiter_sel,
			wbwide_sdio_sel,
			wbwide_i2cdma_sel,
			wbwide_i2cm_sel
		}),
		.o_mstall({
			wbwide_zip_stall,
			wbwide_wbu_arbiter_stall,
			wbwide_sdio_stall,
			wbwide_i2cdma_stall,
			wbwide_i2cm_stall
		}),
		.o_mack({
			wbwide_zip_ack,
			wbwide_wbu_arbiter_ack,
			wbwide_sdio_ack,
			wbwide_i2cdma_ack,
			wbwide_i2cm_ack
		}),
		.o_mdata({
			wbwide_zip_idata,
			wbwide_wbu_arbiter_idata,
			wbwide_sdio_idata,
			wbwide_i2cdma_idata,
			wbwide_i2cm_idata
		}),
		.o_merr({
			wbwide_zip_err,
			wbwide_wbu_arbiter_err,
			wbwide_sdio_err,
			wbwide_i2cdma_err,
			wbwide_i2cm_err
		}),
		// Slave connections
		.o_scyc({
			wbwide_bkram_cyc,
			wbwide_crossbus_cyc,
			wbwide_crossflash_cyc,
			wbwide_ddr3_cyc
		}),
		.o_sstb({
			wbwide_bkram_stb,
			wbwide_crossbus_stb,
			wbwide_crossflash_stb,
			wbwide_ddr3_stb
		}),
		.o_swe({
			wbwide_bkram_we,
			wbwide_crossbus_we,
			wbwide_crossflash_we,
			wbwide_ddr3_we
		}),
		.o_saddr({
			wbwide_bkram_addr,
			wbwide_crossbus_addr,
			wbwide_crossflash_addr,
			wbwide_ddr3_addr
		}),
		.o_sdata({
			wbwide_bkram_data,
			wbwide_crossbus_data,
			wbwide_crossflash_data,
			wbwide_ddr3_data
		}),
		.o_ssel({
			wbwide_bkram_sel,
			wbwide_crossbus_sel,
			wbwide_crossflash_sel,
			wbwide_ddr3_sel
		}),
		.i_sstall({
			wbwide_bkram_stall,
			wbwide_crossbus_stall,
			wbwide_crossflash_stall,
			wbwide_ddr3_stall
		}),
		.i_sack({
			wbwide_bkram_ack,
			wbwide_crossbus_ack,
			wbwide_crossflash_ack,
			wbwide_ddr3_ack
		}),
		.i_sdata({
			wbwide_bkram_idata,
			wbwide_crossbus_idata,
			wbwide_crossflash_idata,
			wbwide_ddr3_idata
		}),
		.i_serr({
			wbwide_bkram_err,
			wbwide_crossbus_err,
			wbwide_crossflash_err,
			wbwide_ddr3_err
		})
		);

	// End of bus logic for wbwide
	// }}}
	//
	// BUS-LOGIC for wb32
	// {{{
	//
	// wb32 Bus logic to handle SINGLE slaves
	//
	reg		r_wb32_sio_ack;
	reg	[31:0]	r_wb32_sio_data;

	assign	wb32_sio_stall = 1'b0;

	initial r_wb32_sio_ack = 1'b0;
	always	@(posedge i_clk)
		r_wb32_sio_ack <= (wb32_sio_stb);
	assign	wb32_sio_ack = r_wb32_sio_ack;

	always	@(posedge i_clk)
	casez( wb32_sio_addr[3:0] )
	4'h0: r_wb32_sio_data <= wb32_adcclk_idata;
	4'h1: r_wb32_sio_data <= wb32_buildtime_idata;
	4'h2: r_wb32_sio_data <= wb32_buspic_idata;
	4'h3: r_wb32_sio_data <= wb32_pwrcount_idata;
	4'h4: r_wb32_sio_data <= wb32_rtccount_idata;
	4'h5: r_wb32_sio_data <= wb32_rxeth0ck_idata;
	4'h6: r_wb32_sio_data <= wb32_spio_idata;
	4'h7: r_wb32_sio_data <= wb32_txclk_idata;
	4'h8: r_wb32_sio_data <= wb32_version_idata;
	default: r_wb32_sio_data <= wb32_version_idata;
	endcase
	assign	wb32_sio_idata = r_wb32_sio_data;


	//
	// Now to translate this logic to the various SIO slaves
	//
	// In this case, the SIO bus has the prefix wb32_sio
	// and all of the slaves have various wires beginning
	// with their own respective bus prefixes.
	// Our goal here is to make certain that all of
	// the slave bus inputs match the SIO bus wires
	assign	wb32_adcclk_cyc = wb32_sio_cyc;
	assign	wb32_adcclk_stb = wb32_sio_stb && (wb32_sio_addr[ 3: 0] ==  4'h0);  // 0x000
	assign	wb32_adcclk_we  = wb32_sio_we;
	assign	wb32_adcclk_data= wb32_sio_data;
	assign	wb32_adcclk_sel = wb32_sio_sel;
	assign	wb32_buildtime_cyc = wb32_sio_cyc;
	assign	wb32_buildtime_stb = wb32_sio_stb && (wb32_sio_addr[ 3: 0] ==  4'h1);  // 0x004
	assign	wb32_buildtime_we  = wb32_sio_we;
	assign	wb32_buildtime_data= wb32_sio_data;
	assign	wb32_buildtime_sel = wb32_sio_sel;
	assign	wb32_buspic_cyc = wb32_sio_cyc;
	assign	wb32_buspic_stb = wb32_sio_stb && (wb32_sio_addr[ 3: 0] ==  4'h2);  // 0x008
	assign	wb32_buspic_we  = wb32_sio_we;
	assign	wb32_buspic_data= wb32_sio_data;
	assign	wb32_buspic_sel = wb32_sio_sel;
	assign	wb32_pwrcount_cyc = wb32_sio_cyc;
	assign	wb32_pwrcount_stb = wb32_sio_stb && (wb32_sio_addr[ 3: 0] ==  4'h3);  // 0x00c
	assign	wb32_pwrcount_we  = wb32_sio_we;
	assign	wb32_pwrcount_data= wb32_sio_data;
	assign	wb32_pwrcount_sel = wb32_sio_sel;
	assign	wb32_rtccount_cyc = wb32_sio_cyc;
	assign	wb32_rtccount_stb = wb32_sio_stb && (wb32_sio_addr[ 3: 0] ==  4'h4);  // 0x010
	assign	wb32_rtccount_we  = wb32_sio_we;
	assign	wb32_rtccount_data= wb32_sio_data;
	assign	wb32_rtccount_sel = wb32_sio_sel;
	assign	wb32_rxeth0ck_cyc = wb32_sio_cyc;
	assign	wb32_rxeth0ck_stb = wb32_sio_stb && (wb32_sio_addr[ 3: 0] ==  4'h5);  // 0x014
	assign	wb32_rxeth0ck_we  = wb32_sio_we;
	assign	wb32_rxeth0ck_data= wb32_sio_data;
	assign	wb32_rxeth0ck_sel = wb32_sio_sel;
	assign	wb32_spio_cyc = wb32_sio_cyc;
	assign	wb32_spio_stb = wb32_sio_stb && (wb32_sio_addr[ 3: 0] ==  4'h6);  // 0x018
	assign	wb32_spio_we  = wb32_sio_we;
	assign	wb32_spio_data= wb32_sio_data;
	assign	wb32_spio_sel = wb32_sio_sel;
	assign	wb32_txclk_cyc = wb32_sio_cyc;
	assign	wb32_txclk_stb = wb32_sio_stb && (wb32_sio_addr[ 3: 0] ==  4'h7);  // 0x01c
	assign	wb32_txclk_we  = wb32_sio_we;
	assign	wb32_txclk_data= wb32_sio_data;
	assign	wb32_txclk_sel = wb32_sio_sel;
	assign	wb32_version_cyc = wb32_sio_cyc;
	assign	wb32_version_stb = wb32_sio_stb && (wb32_sio_addr[ 3: 0] ==  4'h8);  // 0x020
	assign	wb32_version_we  = wb32_sio_we;
	assign	wb32_version_data= wb32_sio_data;
	assign	wb32_version_sel = wb32_sio_sel;
	//
	// No class DOUBLE peripherals on the "wb32" bus
	//

	assign	wb32_flashcfg_err= 1'b0;
	assign	wb32_flashdbg_err= 1'b0;
	assign	wb32_sdioscope_err= 1'b0;
	assign	wb32_i2cs_err= 1'b0;
	assign	wb32_i2cdma_err= 1'b0;
	assign	wb32_uart_err= 1'b0;
	assign	wb32_sio_err= 1'b0;
	assign	wb32_cfg_err= 1'b0;
	assign	wb32_eth0_err= 1'b0;
	assign	wb32_ddr3_phy_err= 1'b0;
	assign	wb32_mdio_err= 1'b0;
	//
	// Connect the wb32 bus components together using the wbxbar()
	//
	//
	wbxbar #(
		.NM(1), .NS(11), .AW(11), .DW(32),
		.SLAVE_ADDR({
			// Address width    = 11
			// Address LSBs     = 2
			{ 11'h400 }, //      mdio: 0x1000
			{ 11'h380 }, //  ddr3_phy: 0x0e00
			{ 11'h300 }, //      eth0: 0x0c00
			{ 11'h2c0 }, //       cfg: 0x0b00
			{ 11'h280 }, //  wb32_sio: 0x0a00
			{ 11'h240 }, //      uart: 0x0900
			{ 11'h200 }, //    i2cdma: 0x0800
			{ 11'h1c0 }, //       i2c: 0x0700
			{ 11'h180 }, // sdioscope: 0x0600
			{ 11'h140 }, //  flashdbg: 0x0500
			{ 11'h100 }  //  flashcfg: 0x0400
		}),
		.SLAVE_MASK({
			// Address width    = 11
			// Address LSBs     = 2
			{ 11'h400 }, //      mdio
			{ 11'h780 }, //  ddr3_phy
			{ 11'h7c0 }, //      eth0
			{ 11'h7c0 }, //       cfg
			{ 11'h7c0 }, //  wb32_sio
			{ 11'h7c0 }, //      uart
			{ 11'h7c0 }, //    i2cdma
			{ 11'h7c0 }, //       i2c
			{ 11'h7c0 }, // sdioscope
			{ 11'h7c0 }, //  flashdbg
			{ 11'h7c0 }  //  flashcfg
		}),
		.OPT_DBLBUFFER(1'b1))
	wb32_xbar(
		.i_clk(i_clk), .i_reset(i_reset),
		.i_mcyc({
			wb32_crossbus_cyc
		}),
		.i_mstb({
			wb32_crossbus_stb
		}),
		.i_mwe({
			wb32_crossbus_we
		}),
		.i_maddr({
			wb32_crossbus_addr
		}),
		.i_mdata({
			wb32_crossbus_data
		}),
		.i_msel({
			wb32_crossbus_sel
		}),
		.o_mstall({
			wb32_crossbus_stall
		}),
		.o_mack({
			wb32_crossbus_ack
		}),
		.o_mdata({
			wb32_crossbus_idata
		}),
		.o_merr({
			wb32_crossbus_err
		}),
		// Slave connections
		.o_scyc({
			wb32_mdio_cyc,
			wb32_ddr3_phy_cyc,
			wb32_eth0_cyc,
			wb32_cfg_cyc,
			wb32_sio_cyc,
			wb32_uart_cyc,
			wb32_i2cdma_cyc,
			wb32_i2cs_cyc,
			wb32_sdioscope_cyc,
			wb32_flashdbg_cyc,
			wb32_flashcfg_cyc
		}),
		.o_sstb({
			wb32_mdio_stb,
			wb32_ddr3_phy_stb,
			wb32_eth0_stb,
			wb32_cfg_stb,
			wb32_sio_stb,
			wb32_uart_stb,
			wb32_i2cdma_stb,
			wb32_i2cs_stb,
			wb32_sdioscope_stb,
			wb32_flashdbg_stb,
			wb32_flashcfg_stb
		}),
		.o_swe({
			wb32_mdio_we,
			wb32_ddr3_phy_we,
			wb32_eth0_we,
			wb32_cfg_we,
			wb32_sio_we,
			wb32_uart_we,
			wb32_i2cdma_we,
			wb32_i2cs_we,
			wb32_sdioscope_we,
			wb32_flashdbg_we,
			wb32_flashcfg_we
		}),
		.o_saddr({
			wb32_mdio_addr,
			wb32_ddr3_phy_addr,
			wb32_eth0_addr,
			wb32_cfg_addr,
			wb32_sio_addr,
			wb32_uart_addr,
			wb32_i2cdma_addr,
			wb32_i2cs_addr,
			wb32_sdioscope_addr,
			wb32_flashdbg_addr,
			wb32_flashcfg_addr
		}),
		.o_sdata({
			wb32_mdio_data,
			wb32_ddr3_phy_data,
			wb32_eth0_data,
			wb32_cfg_data,
			wb32_sio_data,
			wb32_uart_data,
			wb32_i2cdma_data,
			wb32_i2cs_data,
			wb32_sdioscope_data,
			wb32_flashdbg_data,
			wb32_flashcfg_data
		}),
		.o_ssel({
			wb32_mdio_sel,
			wb32_ddr3_phy_sel,
			wb32_eth0_sel,
			wb32_cfg_sel,
			wb32_sio_sel,
			wb32_uart_sel,
			wb32_i2cdma_sel,
			wb32_i2cs_sel,
			wb32_sdioscope_sel,
			wb32_flashdbg_sel,
			wb32_flashcfg_sel
		}),
		.i_sstall({
			wb32_mdio_stall,
			wb32_ddr3_phy_stall,
			wb32_eth0_stall,
			wb32_cfg_stall,
			wb32_sio_stall,
			wb32_uart_stall,
			wb32_i2cdma_stall,
			wb32_i2cs_stall,
			wb32_sdioscope_stall,
			wb32_flashdbg_stall,
			wb32_flashcfg_stall
		}),
		.i_sack({
			wb32_mdio_ack,
			wb32_ddr3_phy_ack,
			wb32_eth0_ack,
			wb32_cfg_ack,
			wb32_sio_ack,
			wb32_uart_ack,
			wb32_i2cdma_ack,
			wb32_i2cs_ack,
			wb32_sdioscope_ack,
			wb32_flashdbg_ack,
			wb32_flashcfg_ack
		}),
		.i_sdata({
			wb32_mdio_idata,
			wb32_ddr3_phy_idata,
			wb32_eth0_idata,
			wb32_cfg_idata,
			wb32_sio_idata,
			wb32_uart_idata,
			wb32_i2cdma_idata,
			wb32_i2cs_idata,
			wb32_sdioscope_idata,
			wb32_flashdbg_idata,
			wb32_flashcfg_idata
		}),
		.i_serr({
			wb32_mdio_err,
			wb32_ddr3_phy_err,
			wb32_eth0_err,
			wb32_cfg_err,
			wb32_sio_err,
			wb32_uart_err,
			wb32_i2cdma_err,
			wb32_i2cs_err,
			wb32_sdioscope_err,
			wb32_flashdbg_err,
			wb32_flashcfg_err
		})
		);

	// End of bus logic for wb32
	// }}}
	//
	// BUS-LOGIC for wbflash
	// {{{
	//
	// No class SINGLE peripherals on the "wbflash" bus
	//

	//
	// No class DOUBLE peripherals on the "wbflash" bus
	//

	assign	wbflash_sdio_err= 1'b0;
	assign	wbflash_flash_err= 1'b0;
	//
	// Connect the wbflash bus components together using the wbxbar()
	//
	//
	wbxbar #(
		.NM(1), .NS(2), .AW(25), .DW(32),
		.SLAVE_ADDR({
			// Address width    = 25
			// Address LSBs     = 2
			{ 25'h1000000 }, // flash: 0x4000000
			{ 25'h0800000 }  //  sdio: 0x2000000
		}),
		.SLAVE_MASK({
			// Address width    = 25
			// Address LSBs     = 2
			{ 25'h1000000 }, // flash
			{ 25'h1800000 }  //  sdio
		}),
		.OPT_DBLBUFFER(1'b1))
	wbflash_xbar(
		.i_clk(i_clk), .i_reset(i_reset),
		.i_mcyc({
			wbflash_crossflash_cyc
		}),
		.i_mstb({
			wbflash_crossflash_stb
		}),
		.i_mwe({
			wbflash_crossflash_we
		}),
		.i_maddr({
			wbflash_crossflash_addr
		}),
		.i_mdata({
			wbflash_crossflash_data
		}),
		.i_msel({
			wbflash_crossflash_sel
		}),
		.o_mstall({
			wbflash_crossflash_stall
		}),
		.o_mack({
			wbflash_crossflash_ack
		}),
		.o_mdata({
			wbflash_crossflash_idata
		}),
		.o_merr({
			wbflash_crossflash_err
		}),
		// Slave connections
		.o_scyc({
			wbflash_flash_cyc,
			wbflash_sdio_cyc
		}),
		.o_sstb({
			wbflash_flash_stb,
			wbflash_sdio_stb
		}),
		.o_swe({
			wbflash_flash_we,
			wbflash_sdio_we
		}),
		.o_saddr({
			wbflash_flash_addr,
			wbflash_sdio_addr
		}),
		.o_sdata({
			wbflash_flash_data,
			wbflash_sdio_data
		}),
		.o_ssel({
			wbflash_flash_sel,
			wbflash_sdio_sel
		}),
		.i_sstall({
			wbflash_flash_stall,
			wbflash_sdio_stall
		}),
		.i_sack({
			wbflash_flash_ack,
			wbflash_sdio_ack
		}),
		.i_sdata({
			wbflash_flash_idata,
			wbflash_sdio_idata
		}),
		.i_serr({
			wbflash_flash_err,
			wbflash_sdio_err
		})
		);

	// End of bus logic for wbflash
	// }}}
	//
	// BUS-LOGIC for wbu
	// {{{
	//
	// No class SINGLE peripherals on the "wbu" bus
	//

	//
	// No class DOUBLE peripherals on the "wbu" bus
	//

	// info: @ERROR.WIRE for wbu_arbiter matches the buses error name, wbu_wbu_arbiter_err
	assign	wbu_zip_err= 1'b0;
	//
	// Connect the wbu bus components together using the wbxbar()
	//
	//
	wbxbar #(
		.NM(2), .NS(2), .AW(30), .DW(32),
		.SLAVE_ADDR({
			// Address width    = 30
			// Address LSBs     = 2
			{ 30'h20000000 }, //         zip: 0x80000000
			{ 30'h00000000 }  // wbu_arbiter: 0x00000000
		}),
		.SLAVE_MASK({
			// Address width    = 30
			// Address LSBs     = 2
			{ 30'h38000000 }, //         zip
			{ 30'h20000000 }  // wbu_arbiter
		}),
		.OPT_DBLBUFFER(1'b1))
	wbu_xbar(
		.i_clk(i_clk), .i_reset(i_reset),
		.i_mcyc({
			wbu_cyc,
			eth0bus_cyc
		}),
		.i_mstb({
			wbu_stb,
			eth0bus_stb
		}),
		.i_mwe({
			wbu_we,
			eth0bus_we
		}),
		.i_maddr({
			wbu_addr,
			eth0bus_addr
		}),
		.i_mdata({
			wbu_data,
			eth0bus_data
		}),
		.i_msel({
			wbu_sel,
			eth0bus_sel
		}),
		.o_mstall({
			wbu_stall,
			eth0bus_stall
		}),
		.o_mack({
			wbu_ack,
			eth0bus_ack
		}),
		.o_mdata({
			wbu_idata,
			eth0bus_idata
		}),
		.o_merr({
			wbu_err,
			eth0bus_err
		}),
		// Slave connections
		.o_scyc({
			wbu_zip_cyc,
			wbu_wbu_arbiter_cyc
		}),
		.o_sstb({
			wbu_zip_stb,
			wbu_wbu_arbiter_stb
		}),
		.o_swe({
			wbu_zip_we,
			wbu_wbu_arbiter_we
		}),
		.o_saddr({
			wbu_zip_addr,
			wbu_wbu_arbiter_addr
		}),
		.o_sdata({
			wbu_zip_data,
			wbu_wbu_arbiter_data
		}),
		.o_ssel({
			wbu_zip_sel,
			wbu_wbu_arbiter_sel
		}),
		.i_sstall({
			wbu_zip_stall,
			wbu_wbu_arbiter_stall
		}),
		.i_sack({
			wbu_zip_ack,
			wbu_wbu_arbiter_ack
		}),
		.i_sdata({
			wbu_zip_idata,
			wbu_wbu_arbiter_idata
		}),
		.i_serr({
			wbu_zip_err,
			wbu_wbu_arbiter_err
		})
		);

	// End of bus logic for wbu
	// }}}
	// }}}
	////////////////////////////////////////////////////////////////////////
	//
	// Declare the interrupt busses
	// {{{
	// Interrupt busses are defined by anything with a @PIC tag.
	// The @PIC.BUS tag defines the name of the wire bus below,
	// while the @PIC.MAX tag determines the size of the bus width.
	//
	// For your peripheral to be assigned to this bus, it must have an
	// @INT.NAME.WIRE= tag to define the wire name of the interrupt line,
	// and an @INT.NAME.PIC= tag matching the @PIC.BUS tag of the bus
	// your interrupt will be assigned to.  If an @INT.NAME.ID tag also
	// exists, then your interrupt will be assigned to the position given
	// by the ID# in that tag.
	//
	assign	alt_int_vector = {
		1'b0,
		1'b0,
		1'b0,
		1'b0,
		uartrx_int,
		uarttx_int,
		sdioscope_int,
		1'b0,
		1'b0,
		1'b0,
		1'b0,
		1'b0,
		1'b0,
		1'b0,
		1'b0
	};
	assign	bus_int_vector = {
		1'b0,
		1'b0,
		1'b0,
		1'b0,
		1'b0,
		1'b0,
		1'b0,
		1'b0,
		1'b0,
		1'b0,
		1'b0,
		1'b0,
		1'b0,
		flashdbg_int,
		spio_int
	};
	assign	sys_int_vector = {
		1'b0,
		1'b0,
		1'b0,
		1'b0,
		1'b0,
		uarttxf_int,
		uartrxf_int,
		sdio_int,
		w_bus_int,
		1'b0,
		1'b0,
		1'b0,
		1'b0,
		1'b0,
		1'b0
	};
	// }}}
	////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////
	//
	// @MAIN.INSERT and @MAIN.ALT
	// {{{
	////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////
	//
	//
	// Now we turn to defining all of the parts and pieces of what
	// each of the various peripherals does, and what logic it needs.
	//
	// This information comes from the @MAIN.INSERT and @MAIN.ALT tags.
	// If an @ACCESS tag is available, an ifdef is created to handle
	// having the access and not.  If the @ACCESS tag is `defined above
	// then the @MAIN.INSERT code is executed.  If not, the @MAIN.ALT
	// code is exeucted, together with any other cleanup settings that
	// might need to take place--such as returning zeros to the bus,
	// or making sure all of the various interrupt wires are set to
	// zero if the component is not included.
	//
`ifdef	I2CCPU_ACCESS
	// {{{
	////////////////////////////////////////////////////////////////////////
	//
	// The I2C Controller
	// {{{

	wbi2ccpu #(
		.ADDRESS_WIDTH(25),
		.DATA_WIDTH(512),
		.AXIS_ID_WIDTH(2)
	) i2ci (
		// {{{
		.i_clk(i_clk), .i_reset(i_reset),
		.i_wb_cyc(wb32_i2cs_cyc), .i_wb_stb(wb32_i2cs_stb), .i_wb_we(wb32_i2cs_we),
			.i_wb_addr(wb32_i2cs_addr[2-1:0]),
			.i_wb_data(wb32_i2cs_data), // 32 bits wide
			.i_wb_sel(wb32_i2cs_sel),  // 32/8 bits wide
		.o_wb_stall(wb32_i2cs_stall),.o_wb_ack(wb32_i2cs_ack), .o_wb_data(wb32_i2cs_idata),
		.o_pf_cyc(wbwide_i2cm_cyc), .o_pf_stb(wbwide_i2cm_stb), .o_pf_we(wbwide_i2cm_we),
			.o_pf_addr(wbwide_i2cm_addr[25-1:0]),
			.o_pf_data(wbwide_i2cm_data), // 512 bits wide
			.o_pf_sel(wbwide_i2cm_sel),  // 512/8 bits wide
		.i_pf_stall(wbwide_i2cm_stall), .i_pf_ack(wbwide_i2cm_ack), .i_pf_data(wbwide_i2cm_idata), .i_pf_err(wbwide_i2cm_err),
		.i_i2c_sda(i_i2c_sda), .i_i2c_scl(i_i2c_scl),
		.o_i2c_sda(o_i2c_sda), .o_i2c_scl(o_i2c_scl),
		.M_AXIS_TVALID(i2c_valid), .M_AXIS_TREADY(i2c_ready),
			.M_AXIS_TDATA(i2c_data), .M_AXIS_TLAST(i2c_last),
			.M_AXIS_TID(i2c_id),
		.i_sync_signal(ck_pps),
		//
		.o_debug(i2c_debug)
		// }}}
	);

	assign	i2c_ready = (!i2c_valid) || (1'b0
			|| (i2c_id == 0)		// NULL address
			|| (i2c_id == 1)
`ifdef	I2CDMA_ACCESS
			|| (i2c_id == 2 && i2cdma_ready)
`else
			|| (i2c_id == 2)
`endif
			|| (i2c_id > 2));

	// }}}
	// }}}
`else	// I2CCPU_ACCESS
	// {{{
	assign	o_i2c_scl = 1'b1;
	assign	o_i2c_sda = 1'b1;
	// Null bus master
	// {{{
	// }}}
	// Null bus slave
	// {{{

	//
	// In the case that there is no wb32_i2cs peripheral
	// responding on the wb32 bus
	assign	wb32_i2cs_ack   = 1'b0;
	assign	wb32_i2cs_err   = (wb32_i2cs_stb);
	assign	wb32_i2cs_stall = 0;
	assign	wb32_i2cs_idata = 0;

	// }}}
	// }}}
`endif	// I2CCPU_ACCESS

`ifdef	I2CDMA_ACCESS
	// {{{
	wbi2cdma #(
		.AW(25), .DW(512), .SW(8),
		.OPT_LITTLE_ENDIAN(1'b0)
	) u_i2cdma (
		.i_clk(i_clk),
		.i_reset(i_reset),
		//
		.i_wb_cyc(wb32_i2cdma_cyc), .i_wb_stb(wb32_i2cdma_stb), .i_wb_we(wb32_i2cdma_we),
			.i_wb_addr(wb32_i2cdma_addr[2-1:0]),
			.i_wb_data(wb32_i2cdma_data), // 32 bits wide
			.i_wb_sel(wb32_i2cdma_sel),  // 32/8 bits wide
		.o_wb_stall(wb32_i2cdma_stall),.o_wb_ack(wb32_i2cdma_ack), .o_wb_data(wb32_i2cdma_idata),
		.S_VALID(i2c_valid && i2c_id == 2), .S_READY(i2cdma_ready),
			.S_DATA(i2c_data), .S_LAST(i2c_last),
		.o_dma_cyc(wbwide_i2cdma_cyc), .o_dma_stb(wbwide_i2cdma_stb), .o_dma_we(wbwide_i2cdma_we),
			.o_dma_addr(wbwide_i2cdma_addr[25-1:0]),
			.o_dma_data(wbwide_i2cdma_data), // 512 bits wide
			.o_dma_sel(wbwide_i2cdma_sel),  // 512/8 bits wide
		.i_dma_stall(wbwide_i2cdma_stall), .i_dma_ack(wbwide_i2cdma_ack), .i_dma_data(wbwide_i2cdma_idata), .i_dma_err(wbwide_i2cdma_err)
	);

	// }}}
`else	// I2CDMA_ACCESS
	// {{{
	assign	@$(prefix)_ready = 1'b0;
	// Null bus master
	// {{{
	// }}}
	// Null bus slave
	// {{{

	//
	// In the case that there is no wb32_i2cdma peripheral
	// responding on the wb32 bus
	assign	wb32_i2cdma_ack   = 1'b0;
	assign	wb32_i2cdma_err   = (wb32_i2cdma_stb);
	assign	wb32_i2cdma_stall = 0;
	assign	wb32_i2cdma_idata = 0;

	// }}}
	// }}}
`endif	// I2CDMA_ACCESS

`ifdef	SDIO_ACCESS
	// {{{
	////////////////////////////////////////////////////////////////////////
	//
	// SDIO SD Card handling
	// {{{
	////////////////////////////////////////////////////////////////////////
	//
	//

	always @(*)
	begin
		sdio_debug = i_sdio_debug;
		sdio_debug = w_sdio_sub_debug;
	end

	sdio #(
		// {{{
		.LGFIFO(10), .NUMIO(4),
		.MW(32),
		.ADDRESS_WIDTH(25+$clog2(512/8)),
		.DMA_DW(512),
		.OPT_SERDES(1'b0),
		.OPT_EMMC(1'b0),
		.OPT_DMA(1'b1),
		.OPT_DDR(1'b1),
		.OPT_HWRESET(1'b0),
		.OPT_CARD_DETECT(1'b1),
		.OPT_ISTREAM(1'b0),
		.OPT_OSTREAM(1'b0)
		// }}}
	) u_sdio(
		// {{{
		.i_clk(i_clk),
		.i_reset(i_reset),
		.i_wb_cyc(wbflash_sdio_cyc), .i_wb_stb(wbflash_sdio_stb), .i_wb_we(wbflash_sdio_we),
			.i_wb_addr(wbflash_sdio_addr[3-1:0]),
			.i_wb_data(wbflash_sdio_data), // 32 bits wide
			.i_wb_sel(wbflash_sdio_sel),  // 32/8 bits wide
		.o_wb_stall(wbflash_sdio_stall),.o_wb_ack(wbflash_sdio_ack), .o_wb_data(wbflash_sdio_idata),
		.o_dma_cyc(wbwide_sdio_cyc), .o_dma_stb(wbwide_sdio_stb), .o_dma_we(wbwide_sdio_we),
			.o_dma_addr(wbwide_sdio_addr[25-1:0]),
			.o_dma_data(wbwide_sdio_data), // 512 bits wide
			.o_dma_sel(wbwide_sdio_sel),  // 512/8 bits wide
		.i_dma_stall(wbwide_sdio_stall), .i_dma_ack(wbwide_sdio_ack), .i_dma_data(wbwide_sdio_idata), .i_dma_err(wbwide_sdio_err),
		// (Unused) DMA Stream assignments
		// {{{
		.s_valid(1'b0),
		.s_ready(s_sdio_ready),
		.s_data(32'h0),
		//
		.m_valid(m_sdio_valid),
		.m_ready(1'b1),
		.m_data(m_sdio_data),
		.m_last(m_sdio_last),
		// }}}
		.i_card_detect(i_sdio_detect),
		.o_hwreset_n(o_sdio_hwreset_n),
		.o_1p8v(w_sdio_1p8v),
		.o_int(sdio_int),
		//
		.o_cfg_ddr(o_sdio_cfg_ddr),
		.o_cfg_ds(o_sdio_cfg_ds),
		.o_cfg_dscmd(o_sdio_cfg_dscmd),
		.o_cfg_sample_shift(o_sdio_cfg_sample_shift),
		.o_pp_cmd(o_sdio_pp_cmd),
		.o_pp_data(o_sdio_pp_data),
		//
		.o_sdclk(   o_sdio_sdclk),
		.o_cmd_en(  o_sdio_cmd_en),
		.o_cmd_data(o_sdio_cmd_data),
		.o_data_en( o_sdio_data_en),
		.o_rx_en(   o_sdio_rx_en),
		.o_tx_data( o_sdio_tx_data),
		//
		.i_cmd_strb( i_sdio_cmd_strb),
		.i_cmd_data( i_sdio_cmd_data),
		.i_cmd_collision( i_sdio_cmd_collision),
		.i_card_busy(i_sdio_card_busy),
		.i_rx_strb(  i_sdio_rx_strb),
		.i_rx_data(  i_sdio_rx_data),
		//
		.S_AC_VALID(i_sdio_ac_valid),
		.S_AC_DATA( i_sdio_ac_data),
		.S_AD_VALID(i_sdio_ad_valid),
		.S_AD_DATA( i_sdio_ad_data),
		//
		.o_debug(w_sdio_sub_debug)
		// }}}
	);

	// }}}
	// }}}
`else	// SDIO_ACCESS
	// {{{
	// Null bus master
	// {{{
	// }}}
	// Null bus slave
	// {{{

	//
	// In the case that there is no wbflash_sdio peripheral
	// responding on the wbflash bus
	assign	wbflash_sdio_ack   = 1'b0;
	assign	wbflash_sdio_err   = (wbflash_sdio_stb);
	assign	wbflash_sdio_stall = 0;
	assign	wbflash_sdio_idata = 0;

	// }}}
	// Null interrupt definitions
	// {{{
	assign	sdio_int = 1'b0;	// sdio.INT.SDCARD.WIRE
	// }}}
	// }}}
`endif	// SDIO_ACCESS

`ifdef	ETH0BUS_ACCESS
	// {{{
	////////////////////////////////////////////////////////////////////////
	//
	// NETBUS: UDP driven bus master
	// {{{
`ifdef	BUSPIC_ACCESS
	assign	w_eth0bus_int = w_bus_int;
`else
	assign	w_eth0bus_int = 1'b0;
`endif

	netdebug #(
		// {{{
		.LGWATCHDOG(ETH0BUSWATCHDOG),
		.DBG_UDPPORT(UDP_DBGPORT)
		// }}}
	) u_eth0bus (
		// {{{
		.i_clk(i_clk), .i_reset(i_reset),
		// Config
		// {{{
		.i_gpio({ 9'h0, w_eth0bus_int }), .o_gpio(eth0bus_gpout),
		.i_my_ipaddr(eth0_ip_addr),
		.i_interrupt(w_eth0bus_int),
		// }}}
		// Wishbone
		// {{{
		.o_wb_cyc(eth0bus_cyc), .o_wb_stb(eth0bus_stb),
			.o_wb_we(eth0bus_we),
			.o_wb_addr(eth0bus_tmp_addr),
			.o_wb_data(eth0bus_data),
			.o_wb_sel(eth0bus_sel),
		.i_wb_stall(eth0bus_stall),
			.i_wb_ack(eth0bus_ack),
		.i_wb_data(eth0bus_idata),
		.i_wb_err(eth0bus_err),
		// }}}
		// Incoming network data
		// {{{
		.S_AXI_TVALID(eth0_dbg_tvalid), .S_AXI_TREADY(eth0_dbg_tready),
			.S_AXI_TDATA(eth0_dbg_tdata),
		// }}}
		// Return network data
		// {{{
		.M_AXI_TVALID(eth0bus_tvalid),
			.M_AXI_TREADY(eth0bus_tready),
			.M_AXI_TDATA(eth0bus_tdata),
		// }}}
		.o_debug(eth0bus_debug)
		// }}}
	);

	assign	eth0bus_addr = eth0bus_tmp_addr[(30-1):0];
	// }}}
	// }}}
`else	// ETH0BUS_ACCESS
	// {{{
	assign	eth0bus_tvalid = 1'b0;
	assign	eth0bus_tdata  = 32'h0;
	// Null bus master
	// {{{
	// }}}
	// }}}
`endif	// ETH0BUS_ACCESS

`ifdef	SPIO_ACCESS
	// {{{
	//
	// Special purpose I/O driver (buttons, LEDs, and switches)
	//
	assign	w_sw = 1'b0;

	spio #(
		.NBTN(2), .NLEDS(8), .NSW(1)
	) spioi(
		.i_clk(i_clk), .i_reset(i_reset),
		.i_wb_cyc(wb32_spio_cyc), .i_wb_stb(wb32_spio_stb), .i_wb_we(wb32_spio_we),
			.i_wb_data(wb32_spio_data), // 32 bits wide
			.i_wb_sel(wb32_spio_sel),  // 32/8 bits wide
		.o_wb_stall(wb32_spio_stall),.o_wb_ack(wb32_spio_ack), .o_wb_data(wb32_spio_idata),
		.i_sw(w_sw), .i_btn(i_btn), .o_led(w_led),
		.o_int(spio_int)
	);

	// LEDs 5:0 are inverted.  For these LEDs, a '1' is off, and a '0' is
	//  on.  LEDs 7:6 are normal, so that a '1' is on and a '0' is off.
	assign	o_led = { w_led[7:6], ~w_led[5:0] };

	// }}}
`else	// SPIO_ACCESS
	// {{{
	assign	o_led = -1;
	// Null interrupt definitions
	// {{{
	assign	spio_int = 1'b0;	// spio.INT.SPIO.WIRE
	// }}}
	// }}}
`endif	// SPIO_ACCESS

	////////////////////////////////////////////////////////////////////////
	//
	// RTC Counter
	// {{{
	//
	// Using clock i_clk with frequency 100000000
	//
`ifndef	TIMESYNC
	initial	r_rtccount_data = 32'h0;
	always @(posedge i_clk)
		r_rtccount_data <= r_rtccount_data + 43;

	assign	wb32_rtccount_idata = r_rtccount_data;
`else
	assign	wb32_rtccount_idata = timestamp_100mhz[31:0];
`endif
	// }}}
`ifdef	PWRCOUNT_ACCESS
	// {{{
	initial	r_pwrcount_data = 32'h0;
	always @(posedge i_clk)
	if (r_pwrcount_data[31])
		r_pwrcount_data[30:0] <= r_pwrcount_data[30:0] + 1'b1;
	else
		r_pwrcount_data[31:0] <= r_pwrcount_data[31:0] + 1'b1;

	assign	wb32_pwrcount_stall = 1'b0;
	assign	wb32_pwrcount_ack   = wb32_pwrcount_stb;
	assign	wb32_pwrcount_idata = r_pwrcount_data;
	// }}}
`else	// PWRCOUNT_ACCESS
	// {{{
	// }}}
`endif	// PWRCOUNT_ACCESS

`ifdef	CFG_ACCESS
	// {{{
	////////////////////////////////////////////////////////////////////////
	//
	// ICAPE2 driver/controller
	// {{{
	////////////////////////////////////////////////////////////////////////
	//
	//
`ifdef	VERILATOR
	reg	r_cfg_ack;

	initial	r_cfg_ack = 1'b0;
	always @(posedge i_clk)
		r_cfg_ack <= wb32_cfg_stb;
	assign	wb32_cfg_ack   = r_cfg_ack;
	assign	wb32_cfg_stall = 1'b0;
	assign	wb32_cfg_idata = 32'h00;
`else
	wbicapetwo #(
		.LGDIV(ICAPE_LGDIV)
	) cfgport(
		// {{{
		.i_clk(i_clk), .i_reset(i_reset),
		.i_wb_cyc(wb32_cfg_cyc), .i_wb_stb(wb32_cfg_stb), .i_wb_we(wb32_cfg_we),
			.i_wb_addr(wb32_cfg_addr[5-1:0]),
			.i_wb_data(wb32_cfg_data), // 32 bits wide
			.i_wb_sel(wb32_cfg_sel),  // 32/8 bits wide
		.o_wb_stall(wb32_cfg_stall),.o_wb_ack(wb32_cfg_ack), .o_wb_data(wb32_cfg_idata)
		// }}}
	);
`endif
	// }}}
	// }}}
`else	// CFG_ACCESS
	// {{{
	// Null bus slave
	// {{{

	//
	// In the case that there is no wb32_cfg peripheral
	// responding on the wb32 bus
	assign	wb32_cfg_ack   = 1'b0;
	assign	wb32_cfg_err   = (wb32_cfg_stb);
	assign	wb32_cfg_stall = 0;
	assign	wb32_cfg_idata = 0;

	// }}}
	// }}}
`endif	// CFG_ACCESS

`ifdef	EXBUS_MASTER
	// {{{
	////////////////////////////////////////////////////////////////////////
	//
	// EXBUS: USB-UART driven bus master and console
	// {{{
	// The Host USB interface, to be used by the WB-UART bus
	rxuartlite	#(
		// {{{
		.TIMER_BITS(DBGBUSBITS),
		.CLOCKS_PER_BAUD(BUSUART[DBGBUSBITS-1:0])
		// }}}
	) rcv(
		// {{{
		.i_clk(      i_clk),
		.i_uart_rx(i_wbu_uart_rx),
		.o_wr(       wbu_rx_stb),
		.o_data(     wbu_rx_data)
		// }}}
	);

	txuartlite	#(
		// {{{
		.TIMING_BITS(DBGBUSBITS[4:0]),
		.CLOCKS_PER_BAUD(BUSUART[DBGBUSBITS-1:0])
		// }}}
	) txv(
		// {{{
		.i_clk(    i_clk),
		.i_wr(     wbu_tx_stb),
		.i_data(   wbu_tx_data),
		.o_uart_tx(o_wbu_uart_tx),
		.o_busy(   wbu_tx_busy)
		// }}}
	);

`ifndef	BUSPIC_ACCESS
	wire	w_bus_int;
	assign	w_bus_int = 1'b0;
`endif
	// Verilator lint_off UNUSED
	wire	[29:0]	wbu_tmp_addr;
	// Verilator lint_on  UNUSED
	exbuswb #(
		// {{{
		// .LGWATCHDOG(DBGBUSWATCHDOG)
		.ADDRESS_WIDTH(30)
		// }}}
	) genbus(
		// {{{
		.i_clk(i_clk), .i_reset(i_reset),
		.o_reset(ex_reset),
		.i_rx_stb(wbu_rx_stb), .i_rx_byte(wbu_rx_data),
		.o_tx_stb(wbu_tx_stb), .o_tx_byte(wbu_tx_data),
			.i_tx_busy(wbu_tx_busy),
		//
		.i_gpio(2'b00), .o_gpio(ex_gpio),
		//
		.i_console_stb(w_console_tx_stb),
			.i_console_byte(w_console_tx_data),
			.o_console_busy(w_console_busy),
		.o_console_stb(w_console_rx_stb),
			.o_console_byte(w_console_rx_data),
		//
		.o_wb_cyc(wbu_cyc), .o_wb_stb(wbu_stb),
			.o_wb_we(wbu_we),
			.o_wb_addr(wbu_addr),
			.o_wb_data(wbu_data),
			.o_wb_sel(wbu_sel),
		.i_wb_stall(wbu_stall),
			.i_wb_ack(wbu_ack),
		.i_wb_data(wbu_idata),
		.i_wb_err(wbu_err),
		.i_interrupt(w_bus_int)
		// }}}
	);
	// }}}
	// }}}
`else	// EXBUS_MASTER
	// {{{
	// Null bus master
	// {{{
	// }}}
	// }}}
`endif	// EXBUS_MASTER

`ifdef	VERSION_ACCESS
	// {{{
	assign	wb32_version_idata = `DATESTAMP;
	assign	wb32_version_ack = wb32_version_stb;
	assign	wb32_version_stall = 1'b0;
	// }}}
`else	// VERSION_ACCESS
	// {{{
	// }}}
`endif	// VERSION_ACCESS

`ifdef	SDIOSCOPE_SCOPC
	// {{{
	wbscopc #(
		// {{{
		.LGMEM(15),
		.SYNCHRONOUS(1),
		.DEFAULT_HOLDOFF(16380)
		// }}}
	) sdioscopei(
		// {{{
		.i_data_clk(i_clk), .i_ce(1'b1),
		.i_trigger(sdio_debug[31]), .i_data(sdio_debug[30:0]),
		.i_wb_clk(i_clk),
		.i_wb_cyc(wb32_sdioscope_cyc), .i_wb_stb(wb32_sdioscope_stb), .i_wb_we(wb32_sdioscope_we),
			.i_wb_addr(wb32_sdioscope_addr[1-1:0]),
			.i_wb_data(wb32_sdioscope_data), // 32 bits wide
			.i_wb_sel(wb32_sdioscope_sel),  // 32/8 bits wide
		.o_wb_stall(wb32_sdioscope_stall),.o_wb_ack(wb32_sdioscope_ack), .o_wb_data(wb32_sdioscope_idata),
		.o_interrupt(sdioscope_int)
		// }}}
	);
	// }}}
`else	// SDIOSCOPE_SCOPC
	// {{{
	// Null bus slave
	// {{{

	//
	// In the case that there is no wb32_sdioscope peripheral
	// responding on the wb32 bus
	assign	wb32_sdioscope_ack   = 1'b0;
	assign	wb32_sdioscope_err   = (wb32_sdioscope_stb);
	assign	wb32_sdioscope_stall = 0;
	assign	wb32_sdioscope_idata = 0;

	// }}}
	// Null interrupt definitions
	// {{{
	assign	sdioscope_int = 1'b0;	// sdioscope.INT.SDIOSCOPE.WIRE
	// }}}
	// }}}
`endif	// SDIOSCOPE_SCOPC

`ifdef	ETH0_ACCESS
	// {{{
	////////////////////////////////////////////////////////////////////////
	//
	// MegaNET ETH0
	// {{{
	////////////////////////////////////////////////////////////////////////
	//
	//

	meganet #(
		// {{{
		.DEF_HWMAC(DEF_ETH0_HWMAC),
		.DEF_IPADDR(DEF_ETH0_IPADDR),
		.UDP_DBGPORT(UDP_DBGPORT)
		// }}}
	) u_eth0 (
		// {{{
		.S_AXI_ACLK(i_clk), .S_AXI_ARESETN(!i_reset),
		//
		.o_hwmac(eth0_hwmac), .o_ipaddr(eth0_ip_addr),
		.o_ping_hwmac(eth0_last_ping_hwmac),
			.o_ping_ipaddr(eth0_last_ping_ipaddr),
		// Wishbone port
		// {{{
		.i_wb_cyc(wb32_eth0_cyc), .i_wb_stb(wb32_eth0_stb), .i_wb_we(wb32_eth0_we),
			.i_wb_addr(wb32_eth0_addr[5-1:0]),
			.i_wb_data(wb32_eth0_data), // 32 bits wide
			.i_wb_sel(wb32_eth0_sel),  // 32/8 bits wide
		.o_wb_stall(wb32_eth0_stall),.o_wb_ack(wb32_eth0_ack), .o_wb_data(wb32_eth0_idata),
		// }}}
		// ifdef ETH0CPUTX_ACCESS
		// {{{
		.S_CPU_TVALID(eth0cputx_tvalid),
			.S_CPU_TREADY(eth0cputx_tready),
			.S_CPU_TDATA(eth0cputx_tdata),
		// }}}
`ifdef	ETH0BUS_ACCESS
		// {{{
		.S_DBG_TVALID(eth0bus_tvalid),
			.S_DBG_TREADY(eth0bus_tready),
			.S_DBG_TDATA(eth0bus_tdata),
`else
		.S_DBG_TVALID(1'b0),
			.S_DBG_TREADY(eth0_dbg_tready),
			.S_DBG_TDATA(32'h0),
`endif
		// }}}
`ifdef	ETH0_NO_ACCESS
		// {{{
		.S_DATA_TVALID(rxpkt_eth0_valid),
			.S_DATA_TREADY(rxpkt_eth0_ready),
			.S_DATA_TDATA(rxpkt_eth0_data),
`else
		.S_DATA_TVALID(1'b0),
			.S_DATA_TREADY(ign_rxpkt_eth0_ready),
			.S_DATA_TDATA(32'h0),
`endif
		// }}}
		// ifdef ETH0CPURX_ACCESS
		// {{{
		.M_CPU_VALID(eth0cpurx_valid),
			.M_CPU_READY(eth0cpurx_ready),
			.M_CPU_DATA(eth0cpurx_data),
			.M_CPU_LAST(eth0cpurx_last),
			.M_CPU_ABORT(eth0cpurx_abort),
		// }}}
`ifdef	ETH0BUS_ACCESS
		// {{{
		.M_DBG_VALID(eth0_dbg_tvalid),
			.M_DBG_READY(eth0_dbg_tready),
			.M_DBG_DATA(eth0_dbg_tdata),
`else
		.M_DBG_VALID(eth0_dbg_tvalid),
			.M_DBG_READY(1'b1),
			.M_DBG_DATA(eth0_dbg_tdata),
`endif
		// }}}
		// Interface to top-level IOs
		// {{{
		.o_net_reset_n(w_eth0_reset_n),
		.i_net_rx_clk(i_eth0_rx_clk), .i_net_rx_dv(i_eth0_rx_dv),
		.i_net_rx_err(i_eth0_rx_err), .i_net_rxd(i_eth0_rxd),
		//
		.i_net_tx_clk(i_net_tx_clk), .o_net_tx_ck(o_eth0_tx_clk),
		.o_net_tx_ctl(o_eth0_tx_ctl), .o_net_txd(o_eth0_txd),
		// }}}
		.o_debug_clk(eth0_debug_clk),
		.o_debug(eth0_debug)
		// }}}
	);

`ifndef	ETH0CPURX_ACCESS
	// {{{
	assign	eth0cpurx_ready = 1'b1;
	// Verilator lint_off UNUSED
	wire	unused_eth0_cpu_rx;
	assign	unused_eth0_cpu_rx = &{ 1'b0,
			eth0cpurx_valid, eth0cpurx_data,
			eth0cpurx_abort, eth0cpurx_last };
	// Verilator lint_on  UNUSED
	// }}}
`endif

`ifndef	ETH0CPUTX_ACCESS
	// {{{
	assign	eth0cputx_tvalid = 1'b0;
	assign	eth0cputx_tdata  = 32'h0;
	// }}}
`endif


	// }}}
	// }}}
`else	// ETH0_ACCESS
	// {{{
	// Null bus slave
	// {{{

	//
	// In the case that there is no wb32_eth0 peripheral
	// responding on the wb32 bus
	assign	wb32_eth0_ack   = 1'b0;
	assign	wb32_eth0_err   = (wb32_eth0_stb);
	assign	wb32_eth0_stall = 0;
	assign	wb32_eth0_idata = 0;

	// }}}
	// }}}
`endif	// ETH0_ACCESS

`ifdef	TXCLK
	// {{{
	clkcounter #(
		.CLOCKFREQ_HZ(0)	// We'll count PPS externally
	) clktxclkctr(
		.i_sys_clk(i_clk),
		.i_tst_clk(i_net_tx_clk),
		.i_sys_pps(ck_pps),
		.o_sys_counts(wb32_txclk_idata)
	);

	always @(posedge i_clk)
		r_txclk_ack <= !i_reset && wb32_txclk_stb;
	assign	wb32_txclk_ack   = r_txclk_ack;
	assign	wb32_txclk_stall = 1'b0;
	// }}}
`else	// TXCLK
	// {{{
	assign	wb32_txclk_idata = 0;

	initial	r_txclk_ack = 1'b0;
	always @(*)
		r_txclk_ack = 1'b0;
	// }}}
`endif	// TXCLK

	assign	wb32_buildtime_idata = `BUILDTIME;
	assign	wb32_buildtime_ack = wb32_buildtime_stb;
	assign	wb32_buildtime_stall = 1'b0;
`ifdef	NETCTRL_ACCESS
	// {{{
	// Verilator lint_off UNUSED
	wire[31:0]	mdio_debug;
	// Verilator lint_on  UNUSED
	enetctrl #(
		.CLKBITS(6)
	) u_mdio (
		.i_clk(i_clk), .i_reset(i_reset),
		.i_wb_cyc(wb32_mdio_cyc), .i_wb_stb(wb32_mdio_stb), .i_wb_we(wb32_mdio_we),
			.i_wb_addr(wb32_mdio_addr[10-1:0]),
			.i_wb_data(wb32_mdio_data), // 32 bits wide
			.i_wb_sel(wb32_mdio_sel),  // 32/8 bits wide
		.o_wb_stall(wb32_mdio_stall),.o_wb_ack(wb32_mdio_ack), .o_wb_data(wb32_mdio_idata),
		.o_mdclk(o_mdclk), .o_mdio(o_mdio), .i_mdio(i_mdio),
		.o_mdwe(o_mdwe), .o_debug(mdio_debug)
	);
	// }}}
`else	// NETCTRL_ACCESS
	// {{{
	assign	o_mdclk = 1'b1;
	assign	o_mdio  = 1'b1;
	assign	o_mdwe  = 1'b0;
	// Null bus slave
	// {{{

	//
	// In the case that there is no wb32_mdio peripheral
	// responding on the wb32 bus
	assign	wb32_mdio_ack   = 1'b0;
	assign	wb32_mdio_err   = (wb32_mdio_stb);
	assign	wb32_mdio_stall = 0;
	assign	wb32_mdio_idata = 0;

	// }}}
	// }}}
`endif	// NETCTRL_ACCESS

`ifdef	RXETH0CK
	// {{{
	clkcounter #(
		.CLOCKFREQ_HZ(0)	// We'll count PPS externally
	) clkrxeth0ckctr(
		.i_sys_clk(i_clk),
		.i_tst_clk(i_eth0_rx_clk),
		.i_sys_pps(ck_pps),
		.o_sys_counts(wb32_rxeth0ck_idata)
	);

	always @(posedge i_clk)
		r_rxeth0ck_ack <= !i_reset && wb32_rxeth0ck_stb;
	assign	wb32_rxeth0ck_ack   = r_rxeth0ck_ack;
	assign	wb32_rxeth0ck_stall = 1'b0;
	// }}}
`else	// RXETH0CK
	// {{{
	assign	wb32_rxeth0ck_idata = 0;

	initial	r_rxeth0ck_ack = 1'b0;
	always @(*)
		r_rxeth0ck_ack = 1'b0;
	// }}}
`endif	// RXETH0CK

`ifdef	ADCCLK
	// {{{
	clkcounter #(
		.CLOCKFREQ_HZ(0)	// We'll count PPS externally
	) clkadcclkctr(
		.i_sys_clk(i_clk),
		.i_tst_clk(i_clk_200mhz),
		.i_sys_pps(ck_pps),
		.o_sys_counts(wb32_adcclk_idata)
	);

	always @(posedge i_clk)
		r_adcclk_ack <= !i_reset && wb32_adcclk_stb;
	assign	wb32_adcclk_ack   = r_adcclk_ack;
	assign	wb32_adcclk_stall = 1'b0;
	// }}}
`else	// ADCCLK
	// {{{
	assign	wb32_adcclk_idata = 0;

	initial	r_adcclk_ack = 1'b0;
	always @(*)
		r_adcclk_ack = 1'b0;
	// }}}
`endif	// ADCCLK

`ifdef	FLASH_ACCESS
	// {{{
	////////////////////////////////////////////////////////////////////////
	//
	// Flash controller
	// {{{
	qflexpress #(
		// {{{
		.LGFLASHSZ(26), .OPT_CLKDIV(1),
		.OPT_ENDIANSWAP(0),
`ifdef	VERILATOR
		// The Verilator model can't handle an ODD number of dummy
		// cycles.
		.NDUMMY(7 + 1),
`else
		.NDUMMY(7),
`endif
		.RDDELAY(1),
		.OPT_STARTUP_FILE("spansion.hex"),
`ifdef	FLASHCFG_ACCESS
		.OPT_CFG(1'b1)
`else
		.OPT_CFG(1'b0)
`endif
		// }}}
	) flashi(
		// {{{
		.i_clk(i_clk), .i_reset(i_reset),
		// Primary memory reading inputs
		.i_wb_cyc(wbflash_flash_cyc), .i_wb_stb(wbflash_flash_stb), .i_wb_we(wbflash_flash_we),
			.i_wb_addr(wbflash_flash_addr[24-1:0]),
			.i_wb_data(wbflash_flash_data), // 32 bits wide
			.i_wb_sel(wbflash_flash_sel),  // 32/8 bits wide
		.o_wb_stall(wbflash_flash_stall),.o_wb_ack(wbflash_flash_ack), .o_wb_data(wbflash_flash_idata),
		// Configuration bus ports
		.i_cfg_cyc(wb32_flashcfg_cyc), .i_cfg_stb(wb32_flashcfg_stb), .i_cfg_we(wb32_flashcfg_we),
			.i_cfg_data(wb32_flashcfg_data), // 32 bits wide
			.i_cfg_sel(wb32_flashcfg_sel),  // 32/8 bits wide
		.o_cfg_stall(wb32_flashcfg_stall),.o_cfg_ack(wb32_flashcfg_ack), .o_cfg_data(wb32_flashcfg_idata),
		.o_qspi_sck(o_qspi_sck), .o_qspi_cs_n(o_qspi_cs_n),
		.o_qspi_mod(o_qspi_mod), .o_qspi_dat(o_qspi_dat),
			.i_qspi_dat(i_qspi_dat),
		.o_dbg_trigger(flash_dbg_trigger), .o_debug(flash_debug)
		// }}}
	);
	// }}}
	// }}}
`else	// FLASH_ACCESS
	// {{{
	assign	o_qspi_sck  = 1'b1;
	assign	o_qspi_cs_n = 1'b1;
	assign	o_qspi_mod  = 2'b01;
	assign	o_qspi_dat  = 4'b1111;
	// Verilator lint_off UNUSED
	wire	flash_unused = &{ 1'b0, i_qspi_dat };
	// Verilator lint_on UNUSED
	// Null bus slave
	// {{{

	//
	// In the case that there is no wbflash_flash peripheral
	// responding on the wbflash bus
	assign	wbflash_flash_ack   = 1'b0;
	assign	wbflash_flash_err   = (wbflash_flash_stb);
	assign	wbflash_flash_stall = 0;
	assign	wbflash_flash_idata = 0;

	// }}}
	// }}}
`endif	// FLASH_ACCESS

	initial	ck_pps = 1'b0;
	initial	ck_pps_counter = 0;
	always @(posedge i_clk)
	if (ck_pps_counter > 0)
	begin
		ck_pps_counter <= ck_pps_counter - 1;
		ck_pps <= 1'b0;
	end else begin
		ck_pps_counter <= 27'd100_000_000 - 1;
		ck_pps <= 1'b1;
	end
`ifdef	FLASHSCOPE_SCOPC
	// {{{
	wbscopc #(
		// {{{
		.LGMEM(13),
		.SYNCHRONOUS(1),
		.DEFAULT_HOLDOFF((20'h1<<13)-20'h1)
		// }}}
	) flashdbgi(
		// {{{
		.i_data_clk(i_clk), .i_ce(1'b1),
		.i_trigger(flash_dbg_trigger), .i_data(flash_debug[30:0]),
		.i_wb_clk(i_clk),
		.i_wb_cyc(wb32_flashdbg_cyc), .i_wb_stb(wb32_flashdbg_stb), .i_wb_we(wb32_flashdbg_we),
			.i_wb_addr(wb32_flashdbg_addr[1-1:0]),
			.i_wb_data(wb32_flashdbg_data), // 32 bits wide
			.i_wb_sel(wb32_flashdbg_sel),  // 32/8 bits wide
		.o_wb_stall(wb32_flashdbg_stall),.o_wb_ack(wb32_flashdbg_ack), .o_wb_data(wb32_flashdbg_idata),
		.o_interrupt(flashdbg_int)
		// }}}
	);
	// }}}
`else	// FLASHSCOPE_SCOPC
	// {{{
	// Null bus slave
	// {{{

	//
	// In the case that there is no wb32_flashdbg peripheral
	// responding on the wb32 bus
	assign	wb32_flashdbg_ack   = 1'b0;
	assign	wb32_flashdbg_err   = (wb32_flashdbg_stb);
	assign	wb32_flashdbg_stall = 0;
	assign	wb32_flashdbg_idata = 0;

	// }}}
	// Null interrupt definitions
	// {{{
	assign	flashdbg_int = 1'b0;	// flashdbg.INT.FLASHDBG.WIRE
	// }}}
	// }}}
`endif	// FLASHSCOPE_SCOPC

`ifdef	BUSCONSOLE_ACCESS
	// {{{
	////////////////////////////////////////////////////////////////////////
	//
	// WBUBUS: Console instantiations
	// {{{
	wbconsole #(.LGFLEN(6)
	) console(
		// {{{
		.i_clk(i_clk), .i_reset(1'b0),
		.i_wb_cyc(wb32_uart_cyc), .i_wb_stb(wb32_uart_stb), .i_wb_we(wb32_uart_we),
			.i_wb_addr(wb32_uart_addr[2-1:0]),
			.i_wb_data(wb32_uart_data), // 32 bits wide
			.i_wb_sel(wb32_uart_sel),  // 32/8 bits wide
		.o_wb_stall(wb32_uart_stall),.o_wb_ack(wb32_uart_ack), .o_wb_data(wb32_uart_idata),
		.o_uart_stb(w_console_tx_stb), .o_uart_data(w_console_tx_data),
			.i_uart_busy(w_console_busy),
		.i_uart_stb(w_console_rx_stb), .i_uart_data(w_console_rx_data),
		.o_uart_rx_int(uartrx_int), .o_uart_tx_int(uarttx_int),
			.o_uart_rxfifo_int(uartrxf_int),
			.o_uart_txfifo_int(uarttxf_int),
		.o_debug(uart_debug)
		// }}}
	);
	// }}}
	// }}}
`else	// BUSCONSOLE_ACCESS
	// {{{
	// Null bus slave
	// {{{

	//
	// In the case that there is no wb32_uart peripheral
	// responding on the wb32 bus
	assign	wb32_uart_ack   = 1'b0;
	assign	wb32_uart_err   = (wb32_uart_stb);
	assign	wb32_uart_stall = 0;
	assign	wb32_uart_idata = 0;

	// }}}
	// Null interrupt definitions
	// {{{
	assign	uartrxf_int = 1'b0;	// uart.INT.UARTRXF.WIRE
	assign	uarttx_int = 1'b0;	// uart.INT.UARTTX.WIRE
	assign	uarttxf_int = 1'b0;	// uart.INT.UARTTXF.WIRE
	assign	uartrx_int = 1'b0;	// uart.INT.UARTRX.WIRE
	// }}}
	// }}}
`endif	// BUSCONSOLE_ACCESS

	////////////////////////////////////////////////////////////////////////
	//
	// WBUBUS "wbu_arbiter" master->slave connection
	// {{{

	wbupsz #(
		// {{{
		// Slave bus address width : 30
		// Slave address width     : 29
		// Master bus address width: 25
		.ADDRESS_WIDTH(25+$clog2(512/8)),
		.SMALL_DW(32),
		.WIDE_DW(512),
		.OPT_LITTLE_ENDIAN(1'b0)
		// }}}
	) u_wbu_wbwide_downsz (
		// {{{
		.i_clk(i_clk),
		.i_reset(i_reset),
		.i_scyc(wbu_wbu_arbiter_cyc), .i_sstb(wbu_wbu_arbiter_stb), .i_swe(wbu_wbu_arbiter_we),
			.i_saddr(wbu_wbu_arbiter_addr[29-1:0]),
			.i_sdata(wbu_wbu_arbiter_data), // 32 bits wide
			.i_ssel(wbu_wbu_arbiter_sel),  // 32/8 bits wide
		.o_sstall(wbu_wbu_arbiter_stall),.o_sack(wbu_wbu_arbiter_ack), .o_sdata(wbu_wbu_arbiter_idata), .o_serr(wbu_wbu_arbiter_err),
		.o_wcyc(wbwide_wbu_arbiter_cyc), .o_wstb(wbwide_wbu_arbiter_stb), .o_wwe(wbwide_wbu_arbiter_we),
			.o_waddr(wbwide_wbu_arbiter_addr[25-1:0]),
			.o_wdata(wbwide_wbu_arbiter_data), // 512 bits wide
			.o_wsel(wbwide_wbu_arbiter_sel),  // 512/8 bits wide
		.i_wstall(wbwide_wbu_arbiter_stall), .i_wack(wbwide_wbu_arbiter_ack), .i_wdata(wbwide_wbu_arbiter_idata), .i_werr(wbwide_wbu_arbiter_err)
		// }}}
	);

	// }}}
`ifdef	BKRAM_ACCESS
	// {{{
	memdev #(
		.LGMEMSZ(18),
		.DW(512),
		.EXTRACLOCK(1)
	) bkrami(
		.i_clk(i_clk),
		.i_reset(i_reset),
		.i_wb_cyc(wbwide_bkram_cyc), .i_wb_stb(wbwide_bkram_stb), .i_wb_we(wbwide_bkram_we),
			.i_wb_addr(wbwide_bkram_addr[12-1:0]),
			.i_wb_data(wbwide_bkram_data), // 512 bits wide
			.i_wb_sel(wbwide_bkram_sel),  // 512/8 bits wide
		.o_wb_stall(wbwide_bkram_stall),.o_wb_ack(wbwide_bkram_ack), .o_wb_data(wbwide_bkram_idata)
	);
	// }}}
`else	// BKRAM_ACCESS
	// {{{
	// Null bus slave
	// {{{

	//
	// In the case that there is no wbwide_bkram peripheral
	// responding on the wbwide bus
	assign	wbwide_bkram_ack   = 1'b0;
	assign	wbwide_bkram_err   = (wbwide_bkram_stb);
	assign	wbwide_bkram_stall = 0;
	assign	wbwide_bkram_idata = 0;

	// }}}
	// }}}
`endif	// BKRAM_ACCESS

	wbdown #(
		// {{{
		// Slave bus address width: 25
		// Slave address width    : 21
		// Master address width   : 25
		.ADDRESS_WIDTH(21+$clog2(512/8)),
		.WIDE_DW(512),
		.SMALL_DW(32),
		.OPT_LITTLE_ENDIAN(1'b0),
		.OPT_LOWLOGIC(1'b0)
		// }}}
	) u_crossflash (
		// {{{
		.i_clk(i_clk),
		.i_reset(i_reset),
		// Slave/incoming
		// {{{
		.i_wcyc(  wbwide_crossflash_cyc),
		.i_wstb(  wbwide_crossflash_stb),
		.i_wwe(   wbwide_crossflash_we),
		.i_waddr( wbwide_crossflash_addr[21-1:0]),
		.i_wdata( wbwide_crossflash_data),
		.i_wsel(  wbwide_crossflash_sel),
		.o_wstall(wbwide_crossflash_stall),
		.o_wack(  wbwide_crossflash_ack),
		.o_wdata( wbwide_crossflash_idata),
		.o_werr(  wbwide_crossflash_err),
		// }}}
		// Master/down-range/outgoing
		// {{{
		.o_scyc(  wbflash_crossflash_cyc),
		.o_sstb(  wbflash_crossflash_stb),
		.o_swe(   wbflash_crossflash_we),
		.o_saddr( wbflash_crossflash_addr[25-1:0]),
		.o_sdata( wbflash_crossflash_data),
		.o_ssel(  wbflash_crossflash_sel),
		.i_sstall(wbflash_crossflash_stall),
		.i_sack(  wbflash_crossflash_ack),
		.i_sdata( wbflash_crossflash_idata),
		.i_serr(  wbflash_crossflash_err)
		// }}}
		// }}}
	);
`ifdef	FLASHCFG_ACCESS
	// {{{
	// The Flash control interface is defined by the flash instantiation
	// hence we don't need to do anything to define it here.
	// }}}
`else	// FLASHCFG_ACCESS
	// {{{
	// Null bus slave
	// {{{

	//
	// In the case that there is no wb32_flashcfg peripheral
	// responding on the wb32 bus
	assign	wb32_flashcfg_ack   = 1'b0;
	assign	wb32_flashcfg_err   = (wb32_flashcfg_stb);
	assign	wb32_flashcfg_stall = 0;
	assign	wb32_flashcfg_idata = 0;

	// }}}
	// }}}
`endif	// FLASHCFG_ACCESS

`ifdef	SDRAM_ACCESS
	// {{{
	////////////////////////////////////////////////////////////////////////
	//
	// DDR3 Controller instantiation
	// {{{
	ddr3_controller #(
		// {{{
		.CONTROLLER_CLK_PERIOD(SDRAMCONTROLLER_CLK_PERIOD), //ns, period of clock input to this DDR3 controller module
		.DDR3_CLK_PERIOD(DDR3_CLK_PERIOD), //ns, period of clock input to DDR3 RAM device
		.ROW_BITS(SDRAMROW_BITS),	//width of row address
		.COL_BITS(SDRAMCOL_BITS),	//width of column address
		.BA_BITS(SDRAMBA_BITS),	//width of bank address
		.DQ_BITS(SDRAMDQ_BITS),	//width of DQ
		.LANES(SDRAMLANES),		//8 lanes of DQ
		.AUX_WIDTH(SDRAMAUX_WIDTH),	//
		.MICRON_SIM(0),		//simulation for micron ddr3 model (shorten POWER_ON_RESET_HIGH and INITIAL_CKE_LOW)
		.ODELAY_SUPPORTED(1)	//set to 1 when ODELAYE2 is supported
			// }}}
	) u_ddr3 (
		.i_controller_clk(i_clk), //i_controller_clk has period of CONTROLLER_CLK_PERIOD
		.i_rst_n(!i_reset), //200MHz input clock
		// Wishbone 1 (Controller)
		.i_wb_cyc(wbwide_ddr3_cyc), .i_wb_stb(wbwide_ddr3_stb), .i_wb_we(wbwide_ddr3_we),
			.i_wb_addr(wbwide_ddr3_addr[24-1:0]),
			.i_wb_data(wbwide_ddr3_data), // 512 bits wide
			.i_wb_sel(wbwide_ddr3_sel),  // 512/8 bits wide
		.o_wb_stall(wbwide_ddr3_stall),.o_wb_ack(wbwide_ddr3_ack), .o_wb_data(wbwide_ddr3_idata),
		.i_aux(0),
		.o_aux(ddr3_aux_out),	// Leaving this empty would've caused a Verilator warning
		// Wishbone 2 (PHY)
		.i_wb2_cyc(wb32_ddr3_phy_cyc), .i_wb2_stb(wb32_ddr3_phy_stb), .i_wb2_we(wb32_ddr3_phy_we),
			.i_wb2_addr(wb32_ddr3_phy_addr[7-1:0]),
			.i_wb2_data(wb32_ddr3_phy_data), // 32 bits wide
			.i_wb2_sel(wb32_ddr3_phy_sel),  // 32/8 bits wide
		.o_wb2_stall(wb32_ddr3_phy_stall),.o_wb2_ack(wb32_ddr3_phy_ack), .o_wb2_data(wb32_ddr3_phy_idata),
		//
		// PHY interface
		.i_phy_iserdes_data(i_ddr3_iserdes_data),
		.i_phy_iserdes_dqs(i_ddr3_iserdes_dqs),
		.i_phy_iserdes_bitslip_reference(i_ddr3_iserdes_bitslip_reference),
		.i_phy_idelayctrl_rdy(i_ddr3_idelayctrl_rdy),
		.o_phy_cmd(o_ddr3_cmd),
		.o_phy_dqs_tri_control(o_ddr3_dqs_tri_control),
		.o_phy_dq_tri_control(o_ddr3_dq_tri_control),
		.o_phy_toggle_dqs(o_ddr3_toggle_dqs),
		.o_phy_data(o_ddr3_data),
		.o_phy_dm(o_ddr3_dm),
		.o_phy_odelay_data_cntvaluein(o_ddr3_odelay_data_cntvaluein),
		.o_phy_odelay_dqs_cntvaluein(o_ddr3_odelay_dqs_cntvaluein),
		.o_phy_idelay_data_cntvaluein(o_ddr3_idelay_data_cntvaluein),
		.o_phy_idelay_dqs_cntvaluein(o_ddr3_idelay_dqs_cntvaluein),
		.o_phy_odelay_data_ld(o_ddr3_odelay_data_ld),
		.o_phy_odelay_dqs_ld(o_ddr3_odelay_dqs_ld),
		.o_phy_idelay_data_ld(o_ddr3_idelay_data_ld),
		.o_phy_idelay_dqs_ld(o_ddr3_idelay_dqs_ld),
		.o_phy_bitslip(o_ddr3_bitslip),
		.o_phy_write_leveling_calib(o_ddr3_leveling_calib),
		.o_phy_reset(o_ddr3_reset),
		// Debug port
		.o_debug1(ddr3_debug1),
		.o_debug2(ddr3_debug2),
		.o_debug3(ddr3_debug3)
	);
	// }}}
	// }}}
`else	// SDRAM_ACCESS
	// {{{
	// Null bus slave
	// {{{

	//
	// In the case that there is no wbwide_ddr3 peripheral
	// responding on the wbwide bus
	assign	wbwide_ddr3_ack   = 1'b0;
	assign	wbwide_ddr3_err   = (wbwide_ddr3_stb);
	assign	wbwide_ddr3_stall = 0;
	assign	wbwide_ddr3_idata = 0;

	// }}}
	// }}}
`endif	// SDRAM_ACCESS

	assign	i_net_tx_clk = i_clk_125mhz;
`ifdef	BUSPIC_ACCESS
	// {{{
	//
	// The BUS Interrupt controller
	//
	icontrol #(15)
	buspici(
		.i_clk(i_clk), .i_reset(1'b0),
		.i_wb_cyc(wb32_buspic_cyc), .i_wb_stb(wb32_buspic_stb), .i_wb_we(wb32_buspic_we),
			.i_wb_data(wb32_buspic_data), // 32 bits wide
			.i_wb_sel(wb32_buspic_sel),  // 32/8 bits wide
		.o_wb_stall(wb32_buspic_stall),.o_wb_ack(wb32_buspic_ack), .o_wb_data(wb32_buspic_idata),
		.i_brd_ints(bus_int_vector),
		.o_interrupt(w_bus_int)
	);
	// }}}
`else	// BUSPIC_ACCESS
	// {{{
	// Null interrupt definitions
	// {{{
	assign	w_bus_int = 1'b0;	// buspic.INT.BUS.WIRE
	// }}}
	// }}}
`endif	// BUSPIC_ACCESS

	wbdown #(
		// {{{
		// Slave bus address width: 25
		// Slave address width    : 7
		// Master address width   : 11
		.ADDRESS_WIDTH(7+$clog2(512/8)),
		.WIDE_DW(512),
		.SMALL_DW(32),
		.OPT_LITTLE_ENDIAN(1'b0),
		.OPT_LOWLOGIC(1'b0)
		// }}}
	) u_crossbus (
		// {{{
		.i_clk(i_clk),
		.i_reset(i_reset),
		// Slave/incoming
		// {{{
		.i_wcyc(  wbwide_crossbus_cyc),
		.i_wstb(  wbwide_crossbus_stb),
		.i_wwe(   wbwide_crossbus_we),
		.i_waddr( wbwide_crossbus_addr[7-1:0]),
		.i_wdata( wbwide_crossbus_data),
		.i_wsel(  wbwide_crossbus_sel),
		.o_wstall(wbwide_crossbus_stall),
		.o_wack(  wbwide_crossbus_ack),
		.o_wdata( wbwide_crossbus_idata),
		.o_werr(  wbwide_crossbus_err),
		// }}}
		// Master/down-range/outgoing
		// {{{
		.o_scyc(  wb32_crossbus_cyc),
		.o_sstb(  wb32_crossbus_stb),
		.o_swe(   wb32_crossbus_we),
		.o_saddr( wb32_crossbus_addr[11-1:0]),
		.o_sdata( wb32_crossbus_data),
		.o_ssel(  wb32_crossbus_sel),
		.i_sstall(wb32_crossbus_stall),
		.i_sack(  wb32_crossbus_ack),
		.i_sdata( wb32_crossbus_idata),
		.i_serr(  wb32_crossbus_err)
		// }}}
		// }}}
	);
`ifdef	INCLUDE_ZIPCPU
	// {{{
	////////////////////////////////////////////////////////////////////////
	//
	// The ZipCPU/ZipSystem BUS master
	// {{{
	//
	assign	zip_int_vector = { alt_int_vector[14:8], sys_int_vector[14:6] };
	zipsystem #(
		// {{{
		.RESET_ADDRESS(RESET_ADDRESS),
		.ADDRESS_WIDTH(ZIP_ADDRESS_WIDTH + $clog2(512/8)),
		.BUS_WIDTH(512),
		.OPT_LGICACHE(12),
		.OPT_LGDCACHE(12),
		.START_HALTED(ZIP_START_HALTED),
		.RESET_DURATION(20),
		.OPT_PIPELINED(1),
`ifdef	VERILATOR
		.OPT_PROFILER(1'b1),
`else
		.OPT_PROFILER(1'b0),
`endif
`ifdef	ZIPSCOPE_SCOPE
		.OPT_TRACE_PORT(1'b1),
`else
		.OPT_TRACE_PORT(1'b0),
`endif
		.OPT_DISTRIBUTED_REGS(1),
		.EXTERNAL_INTERRUPTS(ZIP_INTS)
		// }}}
	) swic(
		// {{{
		.i_clk(i_clk), .i_reset(i_reset || i_cpu_reset),
			// Zipsys wishbone interface
			.o_wb_cyc(wbwide_zip_cyc), .o_wb_stb(wbwide_zip_stb), .o_wb_we(wbwide_zip_we),
			.o_wb_addr(wbwide_zip_addr[25-1:0]),
			.o_wb_data(wbwide_zip_data), // 512 bits wide
			.o_wb_sel(wbwide_zip_sel),  // 512/8 bits wide
		.i_wb_stall(wbwide_zip_stall), .i_wb_ack(wbwide_zip_ack), .i_wb_data(wbwide_zip_idata), .i_wb_err(wbwide_zip_err),
			.i_ext_int(zip_int_vector), .o_ext_int(zip_cpu_int),
			// Debug wishbone interface
			.i_dbg_cyc(wbu_zip_cyc || cpu_sim_cyc),
			.i_dbg_stb(cpu_sim_cyc ? cpu_sim_stb : wbu_zip_stb),
			.i_dbg_we( cpu_sim_cyc ? cpu_sim_we  : wbu_zip_we),
			.i_dbg_addr(cpu_sim_cyc? cpu_sim_addr : wbu_zip_addr[6:0]),
			.i_dbg_data (cpu_sim_cyc? cpu_sim_data : wbu_zip_data),
			.i_dbg_sel  (cpu_sim_cyc? 4'hf : wbu_zip_sel),
			.o_dbg_stall(raw_cpu_dbg_stall),
			.o_dbg_ack  (raw_cpu_dbg_ack),
			.o_dbg_data (wbu_zip_idata),
			//
			.o_cpu_debug(zip_debug),
			.o_prof_stb(cpu_prof_stb),
			.o_prof_addr(cpu_prof_addr),
			.o_prof_ticks(cpu_prof_ticks)
		// }}}
	);
	assign	zip_trigger = zip_debug[31];

	assign	wbu_zip_stall =  cpu_sim_cyc || raw_cpu_dbg_stall;
	assign	wbu_zip_ack   = !cpu_sim_cyc && raw_cpu_dbg_ack;
	assign	cpu_sim_stall = !cpu_sim_cyc || raw_cpu_dbg_stall;
	assign	cpu_sim_ack   =  cpu_sim_cyc && raw_cpu_dbg_ack;
	assign	cpu_sim_idata = wbu_zip_idata;

	// Keep Verilator happy
	// {{{
	// Verilator lint_off UNUSED
	wire	zip_unused;
	assign	zip_unused = &{ 1'b0,
			alt_int_vector[7:0], sys_int_vector[5:0]};
	// Verilator lint_on  UNUSED
	// }}}
	// }}}
	// }}}
`else	// INCLUDE_ZIPCPU
	// {{{
	// Null bus master
	// {{{
	// }}}
	// Null bus slave
	// {{{

	//
	// In the case that there is no wbu_zip peripheral
	// responding on the wbu bus
	assign	wbu_zip_ack   = 1'b0;
	assign	wbu_zip_err   = (wbu_zip_stb);
	assign	wbu_zip_stall = 0;
	assign	wbu_zip_idata = 0;

	// }}}
	// Null interrupt definitions
	// {{{
	assign	zip_cpu_int = 1'b0;	// zip.INT.ZIP.WIRE
	// }}}
	// }}}
`endif	// INCLUDE_ZIPCPU

	// }}}
endmodule // main.v
